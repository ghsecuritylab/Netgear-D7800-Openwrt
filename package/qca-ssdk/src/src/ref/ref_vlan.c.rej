diff a/package/qca-ssdk/src/src/ref/ref_vlan.c b/package/qca-ssdk/src/src/ref/ref_vlan.c	(rejected hunks)
@@ -45,6 +45,64 @@
 extern struct mutex g_ssdk_reg_mutex;
 
 int
+qca_ar8327_sw_enable_vlan0(a_bool_t enable, a_uint8_t portmap)
+{
+    fal_vlan_t entry;
+    fal_acl_rule_t rule;
+    int i = 0;
+
+    memset(&entry, 0, sizeof(fal_vlan_t));
+    memset(&rule, 0, sizeof(fal_acl_rule_t));
+    for (i = 0; i < AR8327_NUM_PORTS; i ++) {
+        fal_port_tls_set(0, i, A_FALSE);
+        fal_port_vlan_propagation_set(0, i, FAL_VLAN_PROPAGATION_REPLACE);
+    }
+
+    if (enable) {
+        entry.fid = 0;
+        entry.mem_ports = portmap;
+        entry.unmodify_ports = portmap;
+        entry.vid = 0;
+        fal_vlan_entry_append(0, &entry);
+        for (i = 0; i < AR8327_NUM_PORTS; i++) {
+            if (portmap & (0x1 << i)) {
+                fal_port_egvlanmode_set(0, i, FAL_EG_UNTOUCHED);
+                fal_port_tls_set(0, i, A_TRUE);
+                fal_port_vlan_propagation_set(0, i, FAL_VLAN_PROPAGATION_DISABLE);
+                fal_acl_port_udf_profile_set(0, i, FAL_ACL_UDF_TYPE_L2, 12, 4);
+            }
+        }
+
+        fal_acl_list_creat(0, 0, 0);
+        rule.rule_type = FAL_ACL_RULE_UDF;
+        rule.udf_len = 4;
+        rule.udf_val[0] = 0x81;
+        rule.udf_val[1] = 0;
+        rule.udf_val[2] = 0;
+        rule.udf_val[3] = 0;
+        rule.udf_mask[0] = 0xff;
+        rule.udf_mask[1] = 0xff;
+        rule.udf_mask[2] = 0xf;
+        rule.udf_mask[3] = 0xff;
+        FAL_FIELD_FLG_SET(rule.field_flg, FAL_ACL_FIELD_UDF);
+        FAL_ACTION_FLG_SET(rule.action_flg, FAL_ACL_ACTION_REMARK_LOOKUP_VID);
+        fal_acl_rule_add(0, 0, 0, 1, &rule);
+        for (i = 0; i < AR8327_NUM_PORTS; i ++) {
+            fal_acl_list_unbind(0, 0, 0, 0, i);
+            if (portmap & (0x1 << i)) {
+                fal_acl_list_bind(0, 0, 0, 0, i);
+            }
+        }
+        fal_acl_status_set(0, A_TRUE);
+    }
+    else {
+        fal_acl_rule_delete(0, 0, 0, 1);
+    }
+
+    return 0;
+}
+
+int
 qca_ar8327_sw_set_vlan(struct switch_dev *dev,
                        const struct switch_attr *attr,
                        struct switch_val *val)
@@ -132,10 +190,14 @@ qca_ar8327_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
 
         p = &val->value.ports[val->len++];
         p->id = i;
-        if (priv->vlan_tagged & (1 << i))
+        if (priv->vlan_tagged[val->port_vlan] & (1 << i))
             p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
         else
             p->flags = 0;
+
+        /*Handle for VLAN 0*/
+        if (val->port_vlan == 0)
+            p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
     }
 
     return 0;
@@ -148,23 +210,36 @@ qca_ar8327_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
     a_uint8_t *vt = &priv->vlan_table[val->port_vlan];
     int i, j;
 
+    /*Handle for VLAN 0*/
+    if (val->port_vlan == 0) {
+        priv->vlan_table[0] = 0;
+        for (i = 0; i < val->len; i++) {
+            struct switch_port *p = &val->value.ports[i];
+            priv->vlan_table[0] |= (1 << p->id);
+        }
+        return 0;
+    }
+	if (priv->vlan_id[val->port_vlan] == 0)
+		priv->vlan_id[val->port_vlan] = val->port_vlan;
     *vt = 0;
     for (i = 0; i < val->len; i++) {
         struct switch_port *p = &val->value.ports[i];
 
         if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
-            priv->vlan_tagged |= (1 << p->id);
+            priv->vlan_tagged[val->port_vlan] |= (1 << p->id);
         } else {
-            priv->vlan_tagged &= ~(1 << p->id);
+            priv->vlan_tagged[val->port_vlan] &= ~(1 << p->id);
+            if (priv->pvid[p->id] == 0)
             priv->pvid[p->id] = val->port_vlan;
 
             /* make sure that an untagged port does not
              * appear in other vlans */
-            for (j = 0; j < AR8327_MAX_VLANS; j++) {
+            /*
+            for (j = 1; j < AR8327_MAX_VLANS; j++) {
                 if (j == val->port_vlan)
                     continue;
                 priv->vlan_table[j] &= ~(1 << p->id);
-            }
+            }*/
         }
 
         *vt |= 1 << p->id;
@@ -182,31 +257,41 @@ qca_ar8327_sw_hw_apply(struct switch_dev *dev)
 
     mutex_lock(&g_ssdk_reg_mutex);
 
-    /* flush all vlan translation unit entries */
-    fal_vlan_flush(0);
-
     memset(portmask, 0, sizeof(portmask));
     if (!priv->init) {
+        /*Handle VLAN 0 entry*/
+        if (priv->vlan_id[0] == 0 && priv->vlan_table[0] == 0) {
+            qca_ar8327_sw_enable_vlan0(A_FALSE, 0);
+        }
+
         /* calculate the port destination masks and load vlans
          * into the vlan translation unit */
         for (j = 0; j < AR8327_MAX_VLANS; j++) {
             u8 vp = priv->vlan_table[j];
 
-            if (!vp)
+            if (!vp) {
+                fal_vlan_delete(0, priv->vlan_id[j]);
             continue;
-
+            }
+            fal_vlan_delete(0, priv->vlan_id[j]);
             fal_vlan_create(0, priv->vlan_id[j]);
 
             for (i = 0; i < dev->ports; i++) {
                 u8 mask = (1 << i);
                 if (vp & mask) {
                     fal_vlan_member_add(0, priv->vlan_id[j], i,
-                           (mask & priv->vlan_tagged)? FAL_EG_TAGGED : FAL_EG_UNTAGGED);
+                           (mask & priv->vlan_tagged[j])? FAL_EG_TAGGED : FAL_EG_UNTAGGED);
                     portmask[i] |= vp & ~mask;
                 }
             }
 
         }
+
+        /*Hanlde VLAN 0 entry*/
+        if (priv->vlan_id[0] == 0 && priv->vlan_table[0]) {
+            qca_ar8327_sw_enable_vlan0(A_TRUE, priv->vlan_table[0]);
+        }
+
     } else {
         /* vlan disabled:
          * isolate all ports, but connect them to the cpu port */
@@ -227,7 +312,7 @@ qca_ar8327_sw_hw_apply(struct switch_dev *dev)
 
         if (priv->vlan) {
             pvid = priv->vlan_id[priv->pvid[i]];
-            if (priv->vlan_tagged & (1 << i)) {
+            if (priv->vlan_tagged[priv->pvid[i]] & (1 << i)) {
                 egressMode = FAL_EG_TAGGED;
             } else {
                 egressMode = FAL_EG_UNTAGGED;
@@ -240,6 +325,15 @@ qca_ar8327_sw_hw_apply(struct switch_dev *dev)
             ingressMode = FAL_1Q_DISABLE;
         }
 
+        /*If VLAN 0 existes, change member port
+           *egress mode as UNTOUCHED*/
+        if (priv->vlan_id[0] == 0 &&
+              priv->vlan_table[0] &&
+              ((0x1 << i) & priv->vlan_table[0]) &&
+              priv->vlan) {
+            egressMode = FAL_EG_UNTOUCHED;
+        }
+
         fal_port_1qmode_set(0, i, ingressMode);
         fal_port_egvlanmode_set(0, i, egressMode);
         fal_port_default_cvid_set(0, i, pvid);
