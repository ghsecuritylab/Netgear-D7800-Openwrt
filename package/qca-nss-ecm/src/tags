!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
DEBUG_ASSERT	ecm_types.h	366;"	d
DEBUG_ASSERT	ecm_types.h	373;"	d
DEBUG_CHECK_MAGIC	ecm_types.h	368;"	d
DEBUG_CHECK_MAGIC	ecm_types.h	375;"	d
DEBUG_CLEAR_MAGIC	ecm_types.h	370;"	d
DEBUG_CLEAR_MAGIC	ecm_types.h	377;"	d
DEBUG_ECM_IP_ADDR_TO_STRING	ecm_types.h	371;"	d
DEBUG_ECM_IP_ADDR_TO_STRING	ecm_types.h	378;"	d
DEBUG_ERROR	ecm_types.h	367;"	d
DEBUG_ERROR	ecm_types.h	374;"	d
DEBUG_INFO	ecm_types.h	386;"	d
DEBUG_INFO	ecm_types.h	400;"	d
DEBUG_INFO	ecm_types.h	402;"	d
DEBUG_LEVEL	ecm_bond_notifier.c	71;"	d	file:
DEBUG_LEVEL	ecm_classifier_default.c	60;"	d	file:
DEBUG_LEVEL	ecm_classifier_dscp.c	63;"	d	file:
DEBUG_LEVEL	ecm_classifier_hyfi.c	63;"	d	file:
DEBUG_LEVEL	ecm_classifier_nl.c	61;"	d	file:
DEBUG_LEVEL	ecm_conntrack_notifier.c	70;"	d	file:
DEBUG_LEVEL	ecm_db.c	59;"	d	file:
DEBUG_LEVEL	ecm_front_end_ipv4.c	69;"	d	file:
DEBUG_LEVEL	ecm_front_end_ipv6.c	71;"	d	file:
DEBUG_LEVEL	ecm_interface.c	79;"	d	file:
DEBUG_LEVEL	ecm_tracker.c	59;"	d	file:
DEBUG_LEVEL	ecm_tracker_datagram.c	59;"	d	file:
DEBUG_LEVEL	ecm_tracker_tcp.c	59;"	d	file:
DEBUG_LEVEL	ecm_tracker_udp.c	59;"	d	file:
DEBUG_SET_MAGIC	ecm_types.h	369;"	d
DEBUG_SET_MAGIC	ecm_types.h	376;"	d
DEBUG_TRACE	ecm_types.h	387;"	d
DEBUG_TRACE	ecm_types.h	406;"	d
DEBUG_TRACE	ecm_types.h	408;"	d
DEBUG_WARN	ecm_types.h	385;"	d
DEBUG_WARN	ecm_types.h	394;"	d
DEBUG_WARN	ecm_types.h	396;"	d
ECM_ARPHRD_IPSEC_TUNNEL_TYPE	ecm_db_types.h	191;"	d
ECM_BOND_ID_INVALID	ecm_bond_notifier.c	89;"	d	file:
ECM_CLASSIFIER_ACCELERATION_MODE_ACCEL	ecm_classifier.h	/^	ECM_CLASSIFIER_ACCELERATION_MODE_ACCEL,			\/* Connection can be accelerated whenever *\/$/;"	e	enum:ecm_classifier_acceleration_modes
ECM_CLASSIFIER_ACCELERATION_MODE_DONT_CARE	ecm_classifier.h	/^	ECM_CLASSIFIER_ACCELERATION_MODE_DONT_CARE = 0,		\/* Classifier does not care if the connection is accelerated *\/$/;"	e	enum:ecm_classifier_acceleration_modes
ECM_CLASSIFIER_ACCELERATION_MODE_NO	ecm_classifier.h	/^	ECM_CLASSIFIER_ACCELERATION_MODE_NO,			\/* Connection must not be accelerated *\/$/;"	e	enum:ecm_classifier_acceleration_modes
ECM_CLASSIFIER_DEFAULT_INTERNAL_INSTANCE_MAGIC	ecm_classifier_default.c	78;"	d	file:
ECM_CLASSIFIER_DEFAULT_STATE_FILE_BUFFER_SIZE	ecm_classifier_default.c	125;"	d	file:
ECM_CLASSIFIER_DEFAULT_STATE_FILE_INSTANCE_MAGIC	ecm_classifier_default.c	79;"	d	file:
ECM_CLASSIFIER_DSCP_ENABLE	Makefile	/^ECM_CLASSIFIER_DSCP_ENABLE=y$/;"	m
ECM_CLASSIFIER_DSCP_INSTANCE_MAGIC	ecm_classifier_dscp.c	78;"	d	file:
ECM_CLASSIFIER_HYFI_INSTANCE_MAGIC	ecm_classifier_hyfi.c	78;"	d	file:
ECM_CLASSIFIER_HYFI_SET_IP_COMMAND_FIELDS	ecm_classifier_hyfi.c	668;"	d	file:
ECM_CLASSIFIER_HYFI_STATE_IGNORE	ecm_classifier_hyfi.c	85;"	d	file:
ECM_CLASSIFIER_HYFI_STATE_INIT	ecm_classifier_hyfi.c	83;"	d	file:
ECM_CLASSIFIER_HYFI_STATE_REGISTERED	ecm_classifier_hyfi.c	84;"	d	file:
ECM_CLASSIFIER_NL_ENABLE	Makefile	/^ECM_CLASSIFIER_NL_ENABLE=y$/;"	m
ECM_CLASSIFIER_NL_F_ACCEL	ecm_classifier_nl.c	81;"	d	file:
ECM_CLASSIFIER_NL_F_ACCEL_OK	ecm_classifier_nl.c	82;"	d	file:
ECM_CLASSIFIER_NL_F_CLOSED	ecm_classifier_nl.c	83;"	d	file:
ECM_CLASSIFIER_NL_INSTANCE_MAGIC	ecm_classifier_nl.c	79;"	d	file:
ECM_CLASSIFIER_NL_SET_IP_COMMAND_FIELDS	ecm_classifier_nl.c	1119;"	d	file:
ECM_CLASSIFIER_PROCESS_ACTION_ACCEL_MODE	ecm_classifier.h	70;"	d
ECM_CLASSIFIER_PROCESS_ACTION_DROP	ecm_classifier.h	68;"	d
ECM_CLASSIFIER_PROCESS_ACTION_DSCP	ecm_classifier.h	72;"	d
ECM_CLASSIFIER_PROCESS_ACTION_DSCP_DENY	ecm_classifier.h	73;"	d
ECM_CLASSIFIER_PROCESS_ACTION_QOS_TAG	ecm_classifier.h	69;"	d
ECM_CLASSIFIER_PROCESS_ACTION_TIMER_GROUP	ecm_classifier.h	71;"	d
ECM_CLASSIFIER_RELEVANCE_MAYBE	ecm_classifier.h	/^	ECM_CLASSIFIER_RELEVANCE_MAYBE = 0,	\/* Classifier has not yet determined relevance *\/$/;"	e	enum:ecm_classifier_relevances
ECM_CLASSIFIER_RELEVANCE_NO	ecm_classifier.h	/^	ECM_CLASSIFIER_RELEVANCE_NO,		\/* Classifier is not relevant to a connection (classifier will be unassigned from the connection after returning this from a process() call) *\/$/;"	e	enum:ecm_classifier_relevances
ECM_CLASSIFIER_RELEVANCE_YES	ecm_classifier.h	/^	ECM_CLASSIFIER_RELEVANCE_YES,		\/* Classifier is relevant to the connection, process actions will be inspected by the front end when returning this from a process() call *\/$/;"	e	enum:ecm_classifier_relevances
ECM_CLASSIFIER_TYPES	ecm_classifier.h	/^	ECM_CLASSIFIER_TYPES,			\/* MUST BE LAST *\/$/;"	e	enum:ecm_classifier_types
ECM_CLASSIFIER_TYPE_DEFAULT	ecm_classifier.h	/^	ECM_CLASSIFIER_TYPE_DEFAULT = 0,	\/* MUST BE FIRST, Default classifier *\/$/;"	e	enum:ecm_classifier_types
ECM_CLASSIFIER_TYPE_DSCP	ecm_classifier.h	/^	ECM_CLASSIFIER_TYPE_DSCP,		\/* Provides DSCP and DSCP remarking support *\/$/;"	e	enum:ecm_classifier_types
ECM_CLASSIFIER_TYPE_HYFI	ecm_classifier.h	/^	ECM_CLASSIFIER_TYPE_HYFI,		\/* HyFi classifier *\/$/;"	e	enum:ecm_classifier_types
ECM_CLASSIFIER_TYPE_NL	ecm_classifier.h	/^	ECM_CLASSIFIER_TYPE_NL,			\/* Provides netlink interface *\/$/;"	e	enum:ecm_classifier_types
ECM_CL_NL_GENL_ATTR	ecm_classifier_nl.h	/^enum ECM_CL_NL_GENL_ATTR {$/;"	g
ECM_CL_NL_GENL_ATTR_COUNT	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_ATTR_COUNT,$/;"	e	enum:ECM_CL_NL_GENL_ATTR
ECM_CL_NL_GENL_ATTR_MAX	ecm_classifier_nl.h	56;"	d
ECM_CL_NL_GENL_ATTR_TUPLE	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_ATTR_TUPLE,$/;"	e	enum:ECM_CL_NL_GENL_ATTR
ECM_CL_NL_GENL_ATTR_UNSPEC	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_ATTR_UNSPEC,$/;"	e	enum:ECM_CL_NL_GENL_ATTR
ECM_CL_NL_GENL_CMD	ecm_classifier_nl.h	/^enum ECM_CL_NL_GENL_CMD {$/;"	g
ECM_CL_NL_GENL_CMD_ACCEL	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_CMD_ACCEL,$/;"	e	enum:ECM_CL_NL_GENL_CMD
ECM_CL_NL_GENL_CMD_ACCEL_OK	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_CMD_ACCEL_OK,$/;"	e	enum:ECM_CL_NL_GENL_CMD
ECM_CL_NL_GENL_CMD_CONNECTION_CLOSED	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_CMD_CONNECTION_CLOSED,$/;"	e	enum:ECM_CL_NL_GENL_CMD
ECM_CL_NL_GENL_CMD_COUNT	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_CMD_COUNT,$/;"	e	enum:ECM_CL_NL_GENL_CMD
ECM_CL_NL_GENL_CMD_MAX	ecm_classifier_nl.h	49;"	d
ECM_CL_NL_GENL_CMD_UNSPEC	ecm_classifier_nl.h	/^	ECM_CL_NL_GENL_CMD_UNSPEC,$/;"	e	enum:ECM_CL_NL_GENL_CMD
ECM_CL_NL_GENL_MCGRP	ecm_classifier_nl.h	40;"	d
ECM_CL_NL_GENL_NAME	ecm_classifier_nl.h	39;"	d
ECM_CL_NL_GENL_VERSION	ecm_classifier_nl.h	38;"	d
ECM_DB_CLASSIFIER_DETERMINE_GENERIC_TIMEOUT	ecm_db_types.h	88;"	d
ECM_DB_CLASSIFIER_TYPE_ASSIGNMENT_MAGIC	ecm_db.c	81;"	d	file:
ECM_DB_CONNECTION_BITTORRENT_TIMEOUT	ecm_db_types.h	108;"	d
ECM_DB_CONNECTION_DNS_TIMEOUT	ecm_db_types.h	100;"	d
ECM_DB_CONNECTION_ESP_PENDING_TIMEOUT	ecm_db_types.h	105;"	d
ECM_DB_CONNECTION_ESP_TIMEOUT	ecm_db_types.h	104;"	d
ECM_DB_CONNECTION_FLAGS_INSERTED	ecm_db.c	626;"	d	file:
ECM_DB_CONNECTION_FTP_TIMEOUT	ecm_db_types.h	101;"	d
ECM_DB_CONNECTION_GENERIC_TIMEOUT	ecm_db_types.h	89;"	d
ECM_DB_CONNECTION_H323_TIMEOUT	ecm_db_types.h	102;"	d
ECM_DB_CONNECTION_HASH_SLOTS	ecm_db.c	97;"	d	file:
ECM_DB_CONNECTION_ICMP_TIMEOUT	ecm_db_types.h	95;"	d
ECM_DB_CONNECTION_IGMP_TIMEOUT	ecm_db_types.h	94;"	d
ECM_DB_CONNECTION_IKE_TIMEOUT	ecm_db_types.h	103;"	d
ECM_DB_CONNECTION_INSTANCE_MAGIC	ecm_db.c	74;"	d	file:
ECM_DB_CONNECTION_PPTP_DATA_TIMEOUT	ecm_db_types.h	96;"	d
ECM_DB_CONNECTION_RTCP_TIMEOUT	ecm_db_types.h	97;"	d
ECM_DB_CONNECTION_RTSP_FAST_TIMEOUT	ecm_db_types.h	98;"	d
ECM_DB_CONNECTION_RTSP_SLOW_TIMEOUT	ecm_db_types.h	99;"	d
ECM_DB_CONNECTION_SDP_TIMEOUT	ecm_db_types.h	106;"	d
ECM_DB_CONNECTION_SERIAL_HASH_SLOTS	ecm_db.c	115;"	d	file:
ECM_DB_CONNECTION_SIP_TIMEOUT	ecm_db_types.h	107;"	d
ECM_DB_CONNECTION_TCP_LONG_TIMEOUT	ecm_db_types.h	92;"	d
ECM_DB_CONNECTION_TCP_RST_TIMEOUT	ecm_db_types.h	90;"	d
ECM_DB_CONNECTION_TCP_SHORT_TIMEOUT	ecm_db_types.h	91;"	d
ECM_DB_CONNECTION_UDP_TIMEOUT	ecm_db_types.h	93;"	d
ECM_DB_DIRECTION_BRIDGED	ecm_db_types.h	/^	ECM_DB_DIRECTION_BRIDGED,			\/* BRIDGED *\/$/;"	e	enum:ecm_db_directions
ECM_DB_DIRECTION_EGRESS_NAT	ecm_db_types.h	/^	ECM_DB_DIRECTION_EGRESS_NAT,			\/* LAN->WAN NAT *\/$/;"	e	enum:ecm_db_directions
ECM_DB_DIRECTION_INGRESS_NAT	ecm_db_types.h	/^	ECM_DB_DIRECTION_INGRESS_NAT,			\/* WAN->LAN NAT *\/$/;"	e	enum:ecm_db_directions
ECM_DB_DIRECTION_NON_NAT	ecm_db_types.h	/^	ECM_DB_DIRECTION_NON_NAT,			\/* NET<>NET *\/$/;"	e	enum:ecm_db_directions
ECM_DB_HOST_FLAGS_INSERTED	ecm_db.c	345;"	d	file:
ECM_DB_HOST_HASH_SLOTS	ecm_db.c	136;"	d	file:
ECM_DB_HOST_INSTANCE_MAGIC	ecm_db.c	75;"	d	file:
ECM_DB_IFACE_FLAGS_INSERTED	ecm_db.c	251;"	d	file:
ECM_DB_IFACE_HASH_SLOTS	ecm_db.c	158;"	d	file:
ECM_DB_IFACE_HEIRARCHY_MAX	ecm_db_types.h	282;"	d
ECM_DB_IFACE_INSTANCE_MAGIC	ecm_db.c	79;"	d	file:
ECM_DB_IFACE_TYPE_BRIDGE	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_BRIDGE,			\/* Interface is a bridge interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_COUNT	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_COUNT,			\/* Number of interface types *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_ETHERNET	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_ETHERNET = 0,			\/* Interface is an ethernet type *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_IPSEC_TUNNEL	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_IPSEC_TUNNEL,			\/* Interface is a IPSec tunnel interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_LAG	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_LAG,				\/* Interface is a Link Aggregated interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_LOOPBACK	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_LOOPBACK,			\/* Interface is a loopback interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_PPPOE	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_PPPOE,			\/* Interface is a PPPoE interface (a specific form of PPP that we recognise in the ECM) *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_SIT	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_SIT,				\/* IPv6 in IPv4 tunnel (SIT) interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_TUNIPIP6	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_TUNIPIP6,			\/* IPIP6 Tunnel (TUNNEL6) interface *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_UNKNOWN	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_UNKNOWN,			\/* Interface is unknown to the ECM *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_IFACE_TYPE_VLAN	ecm_db_types.h	/^	ECM_DB_IFACE_TYPE_VLAN,				\/* Interface is a VLAN interface (802.1Q) *\/$/;"	e	enum:ecm_db_iface_types
ECM_DB_LISTENER_FLAGS_INSERTED	ecm_db.c	658;"	d	file:
ECM_DB_LISTENER_INSTANCE_MAGIC	ecm_db.c	77;"	d	file:
ECM_DB_MAPPING_FLAGS_INSERTED	ecm_db.c	414;"	d	file:
ECM_DB_MAPPING_HASH_SLOTS	ecm_db.c	125;"	d	file:
ECM_DB_MAPPING_INSTANCE_MAGIC	ecm_db.c	76;"	d	file:
ECM_DB_NODE_FLAGS_INSERTED	ecm_db.c	307;"	d	file:
ECM_DB_NODE_HASH_SLOTS	ecm_db.c	147;"	d	file:
ECM_DB_NODE_INSTANCE_MAGIC	ecm_db.c	78;"	d	file:
ECM_DB_STATE_FILE_BUFFER_SIZE	ecm_db.c	688;"	d	file:
ECM_DB_STATE_FILE_CTA_FLAG_CONTENT_UNWRITTEN	ecm_db.c	708;"	d	file:
ECM_DB_STATE_FILE_CTA_FLAG_ELEMENT_END_UNWRITTEN	ecm_db.c	709;"	d	file:
ECM_DB_STATE_FILE_CTA_FLAG_ELEMENT_START_UNWRITTEN	ecm_db.c	707;"	d	file:
ECM_DB_STATE_FILE_INSTANCE_MAGIC	ecm_db.c	80;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_CLASSIFIER_TYPE_ASSIGNMENTS	ecm_db.c	702;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_CONNECTIONS	ecm_db.c	691;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_CONNECTIONS_CHAIN	ecm_db.c	696;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_HOSTS	ecm_db.c	693;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_HOSTS_CHAIN	ecm_db.c	698;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_INTERFACES	ecm_db.c	695;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_INTERFACES_CHAIN	ecm_db.c	700;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_MAPPINGS	ecm_db.c	692;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_MAPPINGS_CHAIN	ecm_db.c	697;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_NODES	ecm_db.c	694;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_NODES_CHAIN	ecm_db.c	699;"	d	file:
ECM_DB_STATE_FILE_OUTPUT_PROTOCOL_COUNTS	ecm_db.c	701;"	d	file:
ECM_DB_TIMER_GROUPS_CLASSIFIER_DETERMINE_GENERIC_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CLASSIFIER_DETERMINE_GENERIC_TIMEOUT = 0,$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_BITTORRENT_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_BITTORRENT_TIMEOUT,	\/* Bittorrent connections timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_DNS_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_DNS_TIMEOUT,		\/* DNS timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_ESP_PENDING_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_ESP_PENDING_TIMEOUT,	\/* ESP Pending connection timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_ESP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_ESP_TIMEOUT,		\/* ESP timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_FTP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_FTP_TIMEOUT,		\/* FTP connection timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_GENERIC_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_GENERIC_TIMEOUT,		\/* Generic timeout for a connection *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_H323_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_H323_TIMEOUT,		\/* H323 timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_ICMP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_ICMP_TIMEOUT,		\/* Standard ICMP Timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_IGMP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_IGMP_TIMEOUT,		\/* IGMP timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_IKE_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_IKE_TIMEOUT,		\/* IKE timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_PPTP_DATA_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_PPTP_DATA_TIMEOUT,	\/* PPTP Tunnel Data timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_RTCP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_RTCP_TIMEOUT,		\/* RTCP timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_FAST_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_FAST_TIMEOUT,	\/* RTSP fast static NAT connection timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_SLOW_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_SLOW_TIMEOUT,	\/* RTSP slow static NAT connection timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_RTSP_TIMEOUT,		\/* RTSP connection timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_SDP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_SDP_TIMEOUT,		\/* SDP timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_SIP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_SIP_TIMEOUT,		\/* SIP timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_TCP_LONG_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_TCP_LONG_TIMEOUT,	\/* TCP Long timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_TCP_RESET_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_TCP_RESET_TIMEOUT,	\/* TCP Reset timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_TCP_SHORT_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_TCP_SHORT_TIMEOUT,	\/* TCP Short timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_UDP_GENERIC_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_UDP_GENERIC_TIMEOUT,	\/* Standard UDP Timeout *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_CONNECTION_UDP_WKP_TIMEOUT	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_CONNECTION_UDP_WKP_TIMEOUT,		\/* Standard UDP Timeout for all connections where at least one port is < 1024 *\/$/;"	e	enum:ecm_db_timer_groups
ECM_DB_TIMER_GROUPS_MAX	ecm_db_types.h	/^	ECM_DB_TIMER_GROUPS_MAX					\/* Always the last one *\/$/;"	e	enum:ecm_db_timer_groups
ECM_FRONT_END_ACCELERATION_FAILED	ecm_front_end_types.h	56;"	d
ECM_FRONT_END_ACCELERATION_MODE_ACCEL	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_ACCEL,			\/* Connection is accelerated *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_ACCEL_PENDING	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_ACCEL_PENDING,		\/* Connection is in the process of being accelerated *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_DECEL	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_DECEL = 0,		\/* Connection is not accelerated *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_DECEL_PENDING	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_DECEL_PENDING,		\/* Connection is in the process of being decelerated *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_DECEL	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_DECEL = -6,	\/* Acceleration has permanently failed due to deceleration malfunction *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_DEFUNCT	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_DEFUNCT = -7,	\/* Acceleration has permanently failed due to the connection has become defunct *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_DENIED	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_DENIED = -1,	\/* Acceleration has permanently failed due to can_accel denying accel *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_DRIVER	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_DRIVER = -3,	\/* Acceleration has permanently failed due to too many driver interaction failures *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_NO_ACTION	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_NO_ACTION = -5,	\/* Acceleration has permanently failed due to too many offloads that were rejected without any packets being offloaded *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_NSS	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_NSS = -4,		\/* Acceleration has permanently failed due to too many NSS NAK's *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_MODE_FAIL_RULE	ecm_front_end_types.h	/^	ECM_FRONT_END_ACCELERATION_MODE_FAIL_RULE = -2,		\/* Acceleration has permanently failed due to bad rule data *\/$/;"	e	enum:ecm_front_end_acceleration_modes
ECM_FRONT_END_ACCELERATION_NOT_POSSIBLE	ecm_front_end_types.h	54;"	d
ECM_FRONT_END_ACCELERATION_POSSIBLE	ecm_front_end_types.h	55;"	d
ECM_FRONT_END_IPV4_CONNECTION_NON_PORTED_INSTANCE_MAGIC	ecm_front_end_ipv4.c	97;"	d	file:
ECM_FRONT_END_IPV4_CONNECTION_TCP_INSTANCE_MAGIC	ecm_front_end_ipv4.c	95;"	d	file:
ECM_FRONT_END_IPV4_CONNECTION_UDP_INSTANCE_MAGIC	ecm_front_end_ipv4.c	96;"	d	file:
ECM_FRONT_END_IPV6_CONNECTION_NON_PORTED_INSTANCE_MAGIC	ecm_front_end_ipv6.c	99;"	d	file:
ECM_FRONT_END_IPV6_CONNECTION_TCP_INSTANCE_MAGIC	ecm_front_end_ipv6.c	97;"	d	file:
ECM_FRONT_END_IPV6_CONNECTION_UDP_INSTANCE_MAGIC	ecm_front_end_ipv6.c	98;"	d	file:
ECM_FRONT_END_IPV6_ENABLE	Makefile	/^ECM_FRONT_END_IPV6_ENABLE=y$/;"	m
ECM_HIN4_ADDR_TO_IP_ADDR	ecm_types.h	189;"	d
ECM_HIN6_ADDR_TO_IP_ADDR	ecm_types.h	163;"	d
ECM_INTERFACE_BOND_ENABLE	Makefile	/^ECM_INTERFACE_BOND_ENABLE=y$/;"	m
ECM_INTERFACE_PPP_ENABLE	Makefile	/^ECM_INTERFACE_PPP_ENABLE=y$/;"	m
ECM_INTERFACE_PPP_SUPPORT	ecm_interface.h	25;"	d
ECM_INTERFACE_SIT_ENABLE	Makefile	/^ECM_INTERFACE_SIT_ENABLE=y$/;"	m
ECM_INTERFACE_VLAN_ENABLE	Makefile	/^ECM_INTERFACE_VLAN_ENABLE=y$/;"	m
ECM_IP_ADDR_COPY	ecm_types.h	81;"	d
ECM_IP_ADDR_DOT_FMT	ecm_types.h	40;"	d
ECM_IP_ADDR_IS_NULL	ecm_types.h	53;"	d
ECM_IP_ADDR_IS_V4	ecm_types.h	50;"	d
ECM_IP_ADDR_MATCH	ecm_types.h	46;"	d
ECM_IP_ADDR_NULL	ecm_types.h	56;"	d
ECM_IP_ADDR_OCTAL_FMT	ecm_types.h	39;"	d
ECM_IP_ADDR_TO_DOT	ecm_types.h	44;"	d
ECM_IP_ADDR_TO_HIN4_ADDR	ecm_types.h	202;"	d
ECM_IP_ADDR_TO_HIN6_ADDR	ecm_types.h	176;"	d
ECM_IP_ADDR_TO_LINUX6	ecm_types.h	95;"	d
ECM_IP_ADDR_TO_NIN4_ADDR	ecm_types.h	151;"	d
ECM_IP_ADDR_TO_NIN6_ADDR	ecm_types.h	125;"	d
ECM_IP_ADDR_TO_NSS_IPV6_ADDR	ecm_types.h	213;"	d
ECM_IP_ADDR_TO_OCTAL	ecm_types.h	42;"	d
ECM_LINUX6_TO_IP_ADDR	ecm_types.h	102;"	d
ECM_LINUX6_TO_IP_ADDR	ecm_types.h	88;"	d
ECM_NIN4_ADDR_TO_IP_ADDR	ecm_types.h	138;"	d
ECM_NIN6_ADDR_TO_IP_ADDR	ecm_types.h	112;"	d
ECM_NSS_CONNMGR_DSCP_MARKING_NOT_CONFIGURED	ecm_types.h	29;"	d
ECM_NSS_CONNMGR_VLAN_ID_NOT_CONFIGURED	ecm_types.h	27;"	d
ECM_NSS_CONNMGR_VLAN_MARKING_NOT_CONFIGURED	ecm_types.h	28;"	d
ECM_NSS_IPV6_ADDR_TO_IP_ADDR	ecm_types.h	226;"	d
ECM_TRACKER_CONNECTION_STATE_CLOSED	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_CLOSED,		\/* Has closed, connection remains to service any late packets *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_STATE_CLOSING	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_CLOSING,		\/* Connection has begun process of closing *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_STATE_ESTABLISHED	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_ESTABLISHED,	\/* It is established *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_STATE_ESTABLISHING	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_ESTABLISHING = 0,	\/* Not yet given any indication it is established *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_STATE_FAULT	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_FAULT,		\/* Experienced a fault *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_STATE_MAX	ecm_tracker.h	/^	ECM_TRACKER_CONNECTION_STATE_MAX,		\/* MUST BE LAST *\/$/;"	e	enum:ecm_tracker_connection_states
ECM_TRACKER_CONNECTION_TRACKING_LIMIT_DEFAULT	ecm_tracker.h	24;"	d
ECM_TRACKER_CONNECTION_TRACKING_LIMIT_MAX	ecm_tracker.h	25;"	d
ECM_TRACKER_DATAGRAM_INSTANCE_MAGIC	ecm_tracker_datagram.c	69;"	d	file:
ECM_TRACKER_GLOBAL_DATA_BUFFER_LIMIT_DEFAULT	ecm_tracker.h	23;"	d
ECM_TRACKER_GLOBAL_DATA_LIMIT_DEFAULT	ecm_tracker.h	22;"	d
ECM_TRACKER_IP_PROTOCOL_TYPE_AH	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_AH,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_COUNT	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_COUNT		\/* Must be last, do not use *\/$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_GRE	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_GRE,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_ICMP	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_ICMP,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_DO	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_DO,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_FRAGMENT	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_FRAGMENT,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_HBH	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_HBH,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_ICMP	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_ICMP,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_ROUTING	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_IPV6_ROUTING,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_TCP	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_TCP,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_UDP	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_UDP,$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_IP_PROTOCOL_TYPE_UNKNOWN	ecm_tracker.h	/^	ECM_TRACKER_IP_PROTOCOL_TYPE_UNKNOWN,		\/* A protocol that is unrecognised *\/$/;"	e	enum:ecm_tracker_ip_protocol_types
ECM_TRACKER_SENDER_MAX	ecm_tracker.h	/^	ECM_TRACKER_SENDER_MAX,			\/* MUST BE LAST *\/$/;"	e	enum:ecm_tracker_sender_types
ECM_TRACKER_SENDER_STATE_CLOSED	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_CLOSED,		\/* Endpoint has closed, connection remains to service any late packets *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_CLOSING	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_CLOSING,		\/* Endpoint has indicated that it wants to close down its side of the connection *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_ESTABLISHED	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_ESTABLISHED,		\/* Endpoint has indicated that it is established *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_ESTABLISHING	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_ESTABLISHING,		\/* Endpoint has not yet given any indication it is established *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_FAULT	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_FAULT,			\/* Endpoint experienced a fault *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_MAX	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_MAX,			\/* MUST BE LAST *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_STATE_UNKNOWN	ecm_tracker.h	/^	ECM_TRACKER_SENDER_STATE_UNKNOWN = 0,		\/* Endpoint has not sent any packets yet *\/$/;"	e	enum:ecm_tracker_sender_states
ECM_TRACKER_SENDER_TYPE_DEST	ecm_tracker.h	/^	ECM_TRACKER_SENDER_TYPE_DEST = 1,	\/* Sender of tracked data is the destination of the connection (to whom connection was established) *\/$/;"	e	enum:ecm_tracker_sender_types
ECM_TRACKER_SENDER_TYPE_SRC	ecm_tracker.h	/^	ECM_TRACKER_SENDER_TYPE_SRC = 0,		\/* Sender of tracked data is the source of the connection (who established the connection) *\/$/;"	e	enum:ecm_tracker_sender_types
ECM_TRACKER_TCP_INSTANCE_MAGIC	ecm_tracker_tcp.c	106;"	d	file:
ECM_TRACKER_TCP_READER_INSTANCE_MAGIC	ecm_tracker_tcp.c	108;"	d	file:
ECM_TRACKER_TCP_SKB_CB_MAGIC	ecm_tracker_tcp.c	107;"	d	file:
ECM_TRACKER_TCP_VALID_FLAGS_MAX	ecm_tracker_tcp.c	84;"	d	file:
ECM_TRACKER_TCP_WORD_HDR_TO_FLAGS	ecm_tracker_tcp.c	79;"	d	file:
ECM_TRACKER_UDP_HEADER_SIZE	ecm_tracker_udp.c	75;"	d	file:
ECM_TRACKER_UDP_INSTANCE_MAGIC	ecm_tracker_udp.c	69;"	d	file:
ECM_TRACKER_UDP_SKB_CB_MAGIC	ecm_tracker_udp.c	70;"	d	file:
NSS_ECM_CL_NL_H_	ecm_classifier_nl.h	17;"	d
TCF_ACK	ecm_tracker_tcp.c	73;"	d	file:
TCF_FIN	ecm_tracker_tcp.c	69;"	d	file:
TCF_PSH	ecm_tracker_tcp.c	72;"	d	file:
TCF_RST	ecm_tracker_tcp.c	71;"	d	file:
TCF_SYN	ecm_tracker_tcp.c	70;"	d	file:
TCF_URG	ecm_tracker_tcp.c	74;"	d	file:
__ECM_IP_ADDR_COPY_NO_CHECK	ecm_types.h	73;"	d
__read_mostly	ecm_front_end_ipv4.c	/^static struct nf_hook_ops ecm_front_end_ipv4_netfilter_hooks[] __read_mostly = {$/;"	v	typeref:struct:ecm_front_end_ipv4_netfilter_hooks	file:
__read_mostly	ecm_front_end_ipv6.c	/^static struct nf_hook_ops ecm_front_end_ipv6_netfilter_hooks[] __read_mostly = {$/;"	v	typeref:struct:ecm_front_end_ipv6_netfilter_hooks	file:
__read_mostly	ecm_interface.c	/^static struct notifier_block ecm_interface_netdev_notifier __read_mostly = {$/;"	v	typeref:struct:ecm_interface_netdev_notifier	file:
_ecm_classifier_default_ref	ecm_classifier_default.c	/^static void _ecm_classifier_default_ref(struct ecm_classifier_default_internal_instance *cdii)$/;"	f	file:
_ecm_db_classifier_type_assignment_remove	ecm_db.c	/^static void _ecm_db_classifier_type_assignment_remove(struct ecm_db_connection_instance *ci, ecm_classifier_type_t ca_type)$/;"	f	file:
_ecm_db_connection_classifier_generation_change	ecm_db.c	/^static void _ecm_db_connection_classifier_generation_change(struct ecm_db_connection_instance *ci)$/;"	f	file:
_ecm_db_connection_ref	ecm_db.c	/^static void _ecm_db_connection_ref(struct ecm_db_connection_instance *ci)$/;"	f	file:
_ecm_db_host_ref	ecm_db.c	/^static void _ecm_db_host_ref(struct ecm_db_host_instance *hi)$/;"	f	file:
_ecm_db_iface_ref	ecm_db.c	/^static void _ecm_db_iface_ref(struct ecm_db_iface_instance *ii)$/;"	f	file:
_ecm_db_listener_ref	ecm_db.c	/^static void _ecm_db_listener_ref(struct ecm_db_listener_instance *li)$/;"	f	file:
_ecm_db_mapping_ref	ecm_db.c	/^static void _ecm_db_mapping_ref(struct ecm_db_mapping_instance *mi)$/;"	f	file:
_ecm_db_node_ref	ecm_db.c	/^static void _ecm_db_node_ref(struct ecm_db_node_instance *ni)$/;"	f	file:
_ecm_db_timer_group_entry_remove	ecm_db.c	/^static bool _ecm_db_timer_group_entry_remove(struct ecm_db_timer_group_entry *tge)$/;"	f	file:
_ecm_db_timer_group_entry_set	ecm_db.c	/^void _ecm_db_timer_group_entry_set(struct ecm_db_timer_group_entry *tge, ecm_db_timer_group_t tg)$/;"	f
_ecm_tracker_tcp_data_future_replay	ecm_tracker_tcp.c	/^static void _ecm_tracker_tcp_data_future_replay(struct ecm_tracker_tcp_internal_instance *ttii,$/;"	f	file:
_ecm_tracker_tcp_discard_all	ecm_tracker_tcp.c	/^static void _ecm_tracker_tcp_discard_all(struct ecm_tracker_tcp_internal_instance *ttii)$/;"	f	file:
_ecm_tracker_tcp_reader_advance	ecm_tracker_tcp.c	/^static void _ecm_tracker_tcp_reader_advance(struct ecm_tracker_tcp_reader_instance *tri, uint32_t advancement)$/;"	f	file:
_ecm_tracker_tcp_reader_retreat	ecm_tracker_tcp.c	/^static void _ecm_tracker_tcp_reader_retreat(struct ecm_tracker_tcp_reader_instance *tri, uint32_t retreatment)$/;"	f	file:
_ecm_tracker_tcp_stream_segment_add	ecm_tracker_tcp.c	/^static bool _ecm_tracker_tcp_stream_segment_add(struct ecm_tracker_tcp_internal_instance *ttii,$/;"	f	file:
accel_ceased	ecm_front_end_types.h	/^	ecm_front_end_connection_accel_ceased_method_t accel_ceased;		\/* Acceleration has stopped *\/$/;"	m	struct:ecm_front_end_connection_instance
accel_mode	ecm_classifier.h	/^	ecm_classifier_acceleration_mode_t accel_mode;	\/* Acceleration needed for this connection *\/$/;"	m	struct:ecm_classifier_process_response
accel_mode	ecm_front_end_ipv4.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates  the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
accel_mode	ecm_front_end_ipv4.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
accel_mode	ecm_front_end_ipv4.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
accel_mode	ecm_front_end_ipv6.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates  the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
accel_mode	ecm_front_end_ipv6.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates  the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
accel_mode	ecm_front_end_ipv6.c	/^	ecm_front_end_acceleration_mode_t accel_mode;		\/* Indicates  the type of acceleration being applied to a connection, if any. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
accel_state_get	ecm_front_end_types.h	/^	ecm_front_end_connection_accel_state_get_method_t accel_state_get;	\/* Get the acceleration state *\/$/;"	m	struct:ecm_front_end_connection_instance
action_seen	ecm_front_end_types.h	/^	ecm_front_end_connection_action_seen_method_t action_seen;		\/* Acceleration action has occurred *\/$/;"	m	struct:ecm_front_end_connection_instance
address	ecm_db.c	/^	ip_addr_t address;				\/* RO: IPv4\/v6 Address of this host *\/$/;"	m	struct:ecm_db_host_instance	file:
address	ecm_db.c	/^	uint8_t address[ETH_ALEN];			\/* RO: MAC Address of this node *\/$/;"	m	struct:ecm_db_node_instance	file:
address	ecm_db_types.h	/^	uint8_t address[ETH_ALEN];			\/* MAC Address of this Interface *\/$/;"	m	struct:ecm_db_interface_info_bridge
address	ecm_db_types.h	/^	uint8_t address[ETH_ALEN];			\/* MAC Address of this Interface *\/$/;"	m	struct:ecm_db_interface_info_ethernet
address	ecm_db_types.h	/^	uint8_t address[ETH_ALEN];			\/* MAC Address of this Interface *\/$/;"	m	struct:ecm_db_interface_info_lag
address	ecm_db_types.h	/^	uint8_t address[ETH_ALEN];			\/* MAC Address of this Interface *\/$/;"	m	struct:ecm_db_interface_info_vlan
af	ecm_classifier_nl.h	/^	uint16_t	af;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
arg	ecm_db.c	/^	void *arg;							\/* Argument returned to owner in callbacks *\/$/;"	m	struct:ecm_db_mapping_instance	file:
arg	ecm_db.c	/^	void *arg;						\/* Argument returned to owner in callbacks *\/$/;"	m	struct:ecm_db_connection_instance	file:
arg	ecm_db.c	/^	void *arg;					\/* Argument returned to owner in callbacks *\/$/;"	m	struct:ecm_db_host_instance	file:
arg	ecm_db.c	/^	void *arg;					\/* Argument returned to owner in callbacks *\/$/;"	m	struct:ecm_db_iface_instance	file:
arg	ecm_db.c	/^	void *arg;					\/* Argument returned to owner in callbacks *\/$/;"	m	struct:ecm_db_node_instance	file:
arg	ecm_db.c	/^	void *arg;$/;"	m	struct:ecm_db_listener_instance	file:
arg	ecm_db_types.h	/^	void *arg;						\/* Argument returned in callback *\/$/;"	m	struct:ecm_db_timer_group_entry
assignments	ecm_db.c	/^	struct ecm_classifier_instance *assignments;		\/* A list of all classifiers that are still assigned to this connection.$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_classifier_instance	file:
assignments_by_type	ecm_db.c	/^	struct ecm_classifier_instance *assignments_by_type[ECM_CLASSIFIER_TYPES];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_classifier_instance	file:
base	ecm_classifier_default.c	/^	struct ecm_classifier_default_instance base;		\/* Base type *\/$/;"	m	struct:ecm_classifier_default_internal_instance	typeref:struct:ecm_classifier_default_internal_instance::ecm_classifier_default_instance	file:
base	ecm_classifier_default.h	/^	struct ecm_classifier_instance base;	\/* Base class implemented by this classifier *\/$/;"	m	struct:ecm_classifier_default_instance	typeref:struct:ecm_classifier_default_instance::ecm_classifier_instance
base	ecm_classifier_dscp.c	/^	struct ecm_classifier_instance base;			\/* Base type *\/$/;"	m	struct:ecm_classifier_dscp_instance	typeref:struct:ecm_classifier_dscp_instance::ecm_classifier_instance	file:
base	ecm_classifier_hyfi.c	/^	struct ecm_classifier_instance base;			\/* Base type *\/$/;"	m	struct:ecm_classifier_hyfi_instance	typeref:struct:ecm_classifier_hyfi_instance::ecm_classifier_instance	file:
base	ecm_classifier_nl.c	/^	struct ecm_classifier_instance base;			\/* Base type *\/$/;"	m	struct:ecm_classifier_nl_instance	typeref:struct:ecm_classifier_nl_instance::ecm_classifier_instance	file:
base	ecm_front_end_ipv4.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	typeref:struct:ecm_front_end_ipv4_connection_non_ported_instance::ecm_front_end_connection_instance	file:
base	ecm_front_end_ipv4.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	typeref:struct:ecm_front_end_ipv4_connection_tcp_instance::ecm_front_end_connection_instance	file:
base	ecm_front_end_ipv4.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	typeref:struct:ecm_front_end_ipv4_connection_udp_instance::ecm_front_end_connection_instance	file:
base	ecm_front_end_ipv6.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	typeref:struct:ecm_front_end_ipv6_connection_non_ported_instance::ecm_front_end_connection_instance	file:
base	ecm_front_end_ipv6.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	typeref:struct:ecm_front_end_ipv6_connection_tcp_instance::ecm_front_end_connection_instance	file:
base	ecm_front_end_ipv6.c	/^	struct ecm_front_end_connection_instance base;		\/* Base class *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	typeref:struct:ecm_front_end_ipv6_connection_udp_instance::ecm_front_end_connection_instance	file:
base	ecm_tracker_datagram.h	/^	struct ecm_tracker_instance base;		\/* MUST BE FIRST *\/$/;"	m	struct:ecm_tracker_datagram_instance	typeref:struct:ecm_tracker_datagram_instance::ecm_tracker_instance
base	ecm_tracker_tcp.h	/^	struct ecm_tracker_instance base;				\/* MUST BE FIRST FIELD *\/$/;"	m	struct:ecm_tracker_tcp_instance	typeref:struct:ecm_tracker_tcp_instance::ecm_tracker_instance
base	ecm_tracker_udp.h	/^	struct ecm_tracker_instance base;					\/* MUST BE FIRST FIELD *\/$/;"	m	struct:ecm_tracker_udp_instance	typeref:struct:ecm_tracker_udp_instance::ecm_tracker_instance
became_relevant	ecm_classifier.h	/^	uint32_t became_relevant;			\/* DB time the classifier became relevant or not relevant, if relevance is maybe this field is not relevant! *\/$/;"	m	struct:ecm_classifier_process_response
bridge	ecm_db.c	/^		struct ecm_db_interface_info_bridge bridge;		\/* type == ECM_DB_IFACE_TYPE_BRIDGE *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_bridge	file:
bytes_avail_get	ecm_tracker_tcp.h	/^	ecm_tracker_tcp_bytes_avail_get_method_t bytes_avail_get;	\/* Return number of bytes available to read *\/$/;"	m	struct:ecm_tracker_tcp_instance
bytes_discard	ecm_tracker_tcp.h	/^	ecm_tracker_tcp_bytes_discard_method_t bytes_discard;		\/* Discard n number of bytes from the beginning of the stream *\/$/;"	m	struct:ecm_tracker_tcp_instance
bytes_read	ecm_tracker_tcp.h	/^	ecm_tracker_tcp_bytes_read_method_t bytes_read;			\/* Read a number of bytes *\/$/;"	m	struct:ecm_tracker_tcp_instance
ca_next	ecm_classifier.h	/^	struct ecm_classifier_instance *ca_next;	\/* DB use only: Connection assignment next pointer *\/$/;"	m	struct:ecm_classifier_instance	typeref:struct:ecm_classifier_instance::ecm_classifier_instance
ca_prev	ecm_classifier.h	/^	struct ecm_classifier_instance *ca_prev;	\/* DB use only: Connection assignment prev pointer *\/$/;"	m	struct:ecm_classifier_instance	typeref:struct:ecm_classifier_instance::ecm_classifier_instance
can_accel	ecm_front_end_ipv4.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
can_accel	ecm_front_end_ipv4.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
can_accel	ecm_front_end_ipv4.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
can_accel	ecm_front_end_ipv6.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
can_accel	ecm_front_end_ipv6.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
can_accel	ecm_front_end_ipv6.c	/^	bool can_accel;						\/* RO: True when the connection can be accelerated *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
cdii	ecm_classifier_default.c	/^	struct ecm_classifier_default_internal_instance *cdii;$/;"	m	struct:ecm_classifier_default_state_file_instance	typeref:struct:ecm_classifier_default_state_file_instance::ecm_classifier_default_internal_instance	file:
ci	ecm_db.c	/^	struct ecm_db_connection_instance *ci;		\/* All connections list iterator *\/$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv4.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	typeref:struct:ecm_front_end_ipv4_connection_non_ported_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv4.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	typeref:struct:ecm_front_end_ipv4_connection_tcp_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv4.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	typeref:struct:ecm_front_end_ipv4_connection_udp_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv6.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	typeref:struct:ecm_front_end_ipv6_connection_non_ported_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv6.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	typeref:struct:ecm_front_end_ipv6_connection_tcp_instance::ecm_db_connection_instance	file:
ci	ecm_front_end_ipv6.c	/^	struct ecm_db_connection_instance *ci;			\/* RO: The connection instance relating to this instance. *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	typeref:struct:ecm_front_end_ipv6_connection_udp_instance::ecm_db_connection_instance	file:
ci_serial	ecm_classifier_default.c	/^	uint32_t ci_serial;					\/* RO: Serial of the connection *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
ci_serial	ecm_classifier_dscp.c	/^	uint32_t ci_serial;					\/* RO: Serial of the connection *\/$/;"	m	struct:ecm_classifier_dscp_instance	file:
ci_serial	ecm_classifier_hyfi.c	/^	uint32_t ci_serial;					\/* RO: Serial of the connection *\/$/;"	m	struct:ecm_classifier_hyfi_instance	file:
ci_serial	ecm_classifier_nl.c	/^	uint32_t ci_serial;					\/* RO: Serial of the connection *\/$/;"	m	struct:ecm_classifier_nl_instance	file:
classifier_generation	ecm_db.c	/^	uint16_t classifier_generation;				\/* Used to detect when a re-evaluation of this connection is necessary *\/$/;"	m	struct:ecm_db_connection_instance	file:
classifier_type_assignments	ecm_db.c	/^	struct ecm_db_connection_instance *classifier_type_assignments[ECM_CLASSIFIER_TYPES];$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_connection_instance	file:
classifier_type_assignments_flags	ecm_db.c	/^	int classifier_type_assignments_flags[ECM_CLASSIFIER_TYPES];$/;"	m	struct:ecm_db_state_file_instance	file:
connection_added	ecm_db.c	/^	ecm_db_connection_listener_added_callback_t connection_added;$/;"	m	struct:ecm_db_listener_instance	file:
connection_hash_index	ecm_db.c	/^	int connection_hash_index;			\/* Connection hash table lengths iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
connection_removed	ecm_db.c	/^	ecm_db_connection_listener_removed_callback_t connection_removed;$/;"	m	struct:ecm_db_listener_instance	file:
daddr	ecm_db_types.h	/^	ip_addr_t daddr;				\/* Tunnel destination address *\/$/;"	m	struct:ecm_db_interface_info_tunipip6
daddr	ecm_db_types.h	/^	ip_addr_t daddr;				\/* Tunnel destination addresss *\/$/;"	m	struct:ecm_db_interface_info_sit
data	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_host_data *data;		\/* Host data this reader is using *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	typeref:struct:ecm_tracker_tcp_reader_instance::ecm_tracker_tcp_host_data	file:
data_limit	ecm_tracker_datagram.c	/^	int32_t data_limit;			\/* Limit for tracked data *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
data_limit	ecm_tracker_tcp.c	/^	int32_t data_limit;								\/* Limit for tracked data *\/$/;"	m	struct:ecm_tracker_tcp_internal_instance	file:
data_limit	ecm_tracker_udp.c	/^	int32_t data_limit;			\/* Limit for tracked data *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
data_limit_get	ecm_tracker.h	/^	ecm_tracker_data_limit_get_method_t data_limit_get;$/;"	m	struct:ecm_tracker_instance
data_limit_set	ecm_tracker.h	/^	ecm_tracker_data_limit_set_method_t data_limit_set;$/;"	m	struct:ecm_tracker_instance
data_offset	ecm_tracker_udp.c	/^	uint32_t data_offset;			\/* Offset in skb data to the actual datagram data - i.e. omitting headers *\/$/;"	m	struct:ecm_tracker_udp_skb_cb_format	file:
data_read	ecm_tracker_udp.h	/^	ecm_tracker_udp_data_read_method_t data_read;				\/* Read data from a UDP datagram (headers not considered) *\/$/;"	m	struct:ecm_tracker_udp_instance
data_size	ecm_tracker_udp.c	/^	uint32_t data_size;			\/* Size of data *\/$/;"	m	struct:ecm_tracker_udp_skb_cb_format	file:
data_size_get	ecm_tracker_udp.h	/^	ecm_tracker_udp_data_size_get_method_t data_size_get;			\/* Get data size of datagram (headers not considered) *\/$/;"	m	struct:ecm_tracker_udp_instance
data_total_get	ecm_tracker.h	/^	ecm_tracker_data_total_get_method_t data_total_get;$/;"	m	struct:ecm_tracker_instance
datagram_add	ecm_tracker.h	/^	ecm_tracker_datagram_add_method_t datagram_add;$/;"	m	struct:ecm_tracker_instance
datagram_add	ecm_tracker_udp.h	/^	ecm_tracker_udp_datagram_add_method_t datagram_add;			\/* Add a pre-checked UDP datagram *\/$/;"	m	struct:ecm_tracker_udp_instance
datagram_base	ecm_tracker_datagram.c	/^	struct ecm_tracker_datagram_instance datagram_base;	\/* MUST BE FIRST FIELD *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	typeref:struct:ecm_tracker_datagram_internal_instance::ecm_tracker_datagram_instance	file:
datagram_count_get	ecm_tracker.h	/^	ecm_tracker_datagram_count_get_method_t datagram_count_get;$/;"	m	struct:ecm_tracker_instance
datagram_discard	ecm_tracker.h	/^	ecm_tracker_datagram_discard_method_t datagram_discard;$/;"	m	struct:ecm_tracker_instance
datagram_read	ecm_tracker.h	/^	ecm_tracker_datagram_read_method_t datagram_read;$/;"	m	struct:ecm_tracker_instance
datagram_size_get	ecm_tracker.h	/^	ecm_tracker_datagram_size_get_method_t datagram_size_get;$/;"	m	struct:ecm_tracker_instance
decelerate	ecm_front_end_types.h	/^	ecm_front_end_connection_decelerate_method_t decelerate;		\/* Decelerate a connection *\/$/;"	m	struct:ecm_front_end_connection_instance
decelerate_pending	ecm_front_end_types.h	/^	bool decelerate_pending;		\/* Decel was attempted during pending accel - will be actioned when accel is done *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
defunct	ecm_db.c	/^	ecm_db_connection_defunct_callback_t defunct;		\/* Callback to be called when connection has become defunct *\/$/;"	m	struct:ecm_db_connection_instance	file:
defunct_timer	ecm_db.c	/^	struct ecm_db_timer_group_entry defunct_timer;		\/* Used to defunct the connection on inactivity *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_timer_group_entry	file:
deref	ecm_classifier.h	/^	ecm_classifier_deref_callback_t deref;$/;"	m	struct:ecm_classifier_instance
deref	ecm_front_end_types.h	/^	ecm_front_end_connection_deref_callback_t deref;			\/* Deref the instance *\/$/;"	m	struct:ecm_front_end_connection_instance
deref	ecm_tracker.h	/^	ecm_tracker_deref_method_t deref;$/;"	m	struct:ecm_tracker_instance
dest_addr	ecm_tracker.h	/^	ip_addr_t dest_addr;		\/* ECM ip address equivalent *\/$/;"	m	struct:ecm_tracker_ip_header
dest_bytes_total	ecm_tracker_datagram.c	/^	int32_t dest_bytes_total;		\/* Total bytes in all received datagrams *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
dest_bytes_total	ecm_tracker_udp.c	/^	int32_t dest_bytes_total;		\/* Total bytes in all received datagrams *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
dest_count	ecm_tracker_datagram.c	/^	int32_t dest_count;			\/* Count of datagrams in list *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
dest_count	ecm_tracker_udp.c	/^	int32_t dest_count;			\/* Count of datagrams in list *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
dest_mac	ecm_classifier_nl.h	/^	uint8_t		dest_mac[ETH_ALEN];$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
dest_recvd_order	ecm_tracker_datagram.c	/^	struct sk_buff *dest_recvd_order;	\/* sk buff list as sent by dest *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	typeref:struct:ecm_tracker_datagram_internal_instance::sk_buff	file:
dest_recvd_order	ecm_tracker_udp.c	/^	struct sk_buff *dest_recvd_order;	\/* sk buff list as sent by dest *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	typeref:struct:ecm_tracker_udp_internal_instance::sk_buff	file:
dest_recvd_order_last	ecm_tracker_datagram.c	/^	struct sk_buff *dest_recvd_order_last;	\/* Last skb send - for fast appending of new buffers *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	typeref:struct:ecm_tracker_datagram_internal_instance::sk_buff	file:
dest_recvd_order_last	ecm_tracker_udp.c	/^	struct sk_buff *dest_recvd_order_last;	\/* Last skb send - for fast appending of new buffers *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	typeref:struct:ecm_tracker_udp_internal_instance::sk_buff	file:
direction	ecm_db.c	/^	ecm_db_direction_t direction;				\/* RO: 'Direction' of connection establishment. *\/$/;"	m	struct:ecm_db_connection_instance	file:
discard_all	ecm_tracker.h	/^	ecm_tracker_discard_all_method_t discard_all;$/;"	m	struct:ecm_tracker_instance
discarded	ecm_tracker_tcp.c	/^	uint32_t discarded;				\/* Tracks the amount of data that has been discarded so far so that we don't try to discard them again.$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
doc_end_written	ecm_classifier_default.c	/^	bool doc_end_written;$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
doc_end_written	ecm_db.c	/^	bool doc_end_written;				\/* Has xml doc closing element been written? *\/$/;"	m	struct:ecm_db_state_file_instance	file:
doc_start_written	ecm_classifier_default.c	/^	bool doc_start_written;$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
doc_start_written	ecm_db.c	/^	bool doc_start_written;				\/* Has xml doc opening element been written? *\/$/;"	m	struct:ecm_db_state_file_instance	file:
driver_fail	ecm_front_end_types.h	/^	uint32_t driver_fail;			\/* Count of consecutive times driver failed to send our command, when this reaches driver_fail_limit acceleration will permanently fail *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
driver_fail_limit	ecm_front_end_types.h	/^	uint32_t driver_fail_limit;		\/* Limit on drivers consecutive fails at which point offload permanently fails out *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
driver_fail_total	ecm_front_end_types.h	/^	uint32_t driver_fail_total;		\/* Total times driver failed to send our command *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
drop	ecm_classifier.h	/^	bool drop;					\/* Drop packet at hand *\/$/;"	m	struct:ecm_classifier_process_response
ds	ecm_tracker.h	/^	uint8_t ds;			\/* DS field from packet *\/$/;"	m	struct:ecm_tracker_ip_header
dst	ecm_interface.h	/^	struct dst_entry *dst;			\/* Both ipv4 and v6 have a common dst entry *\/$/;"	m	struct:ecm_interface_route	typeref:struct:ecm_interface_route::dst_entry
dst_ip	ecm_classifier_nl.h	/^	union ecm_cl_nl_genl_attr_ip dst_ip;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple	typeref:union:ecm_cl_nl_genl_attr_tuple::ecm_cl_nl_genl_attr_ip
dst_port	ecm_classifier_nl.h	/^	uint16_t	dst_port;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
ecm-y	Makefile	/^ecm-y := \\$/;"	m
ecm_bond_notifier_bond_cb	ecm_bond_notifier.c	/^static struct bond_cb ecm_bond_notifier_bond_cb;$/;"	v	typeref:struct:bond_cb	file:
ecm_bond_notifier_bond_enslave	ecm_bond_notifier.c	/^static void ecm_bond_notifier_bond_enslave(struct net_device *slave_dev)$/;"	f	file:
ecm_bond_notifier_bond_link_up	ecm_bond_notifier.c	/^static void ecm_bond_notifier_bond_link_up(struct net_device *slave_dev)$/;"	f	file:
ecm_bond_notifier_bond_release	ecm_bond_notifier.c	/^static void ecm_bond_notifier_bond_release(struct net_device *slave_dev)$/;"	f	file:
ecm_bond_notifier_dev	ecm_bond_notifier.c	/^static struct device ecm_bond_notifier_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_bond_notifier_dev_release	ecm_bond_notifier.c	/^static void ecm_bond_notifier_dev_release(struct device *dev)$/;"	f	file:
ecm_bond_notifier_exit	ecm_bond_notifier.c	/^EXPORT_SYMBOL(ecm_bond_notifier_exit);$/;"	v
ecm_bond_notifier_exit	ecm_bond_notifier.c	/^void ecm_bond_notifier_exit(void)$/;"	f
ecm_bond_notifier_get_stop	ecm_bond_notifier.c	/^static ssize_t ecm_bond_notifier_get_stop(struct device *dev,$/;"	f	file:
ecm_bond_notifier_init	ecm_bond_notifier.c	/^EXPORT_SYMBOL(ecm_bond_notifier_init);$/;"	v
ecm_bond_notifier_init	ecm_bond_notifier.c	/^int ecm_bond_notifier_init(void)$/;"	f
ecm_bond_notifier_lag_event_cb	ecm_bond_notifier.c	/^static void ecm_bond_notifier_lag_event_cb(void *if_ctx, struct nss_lag_msg *msg)$/;"	f	file:
ecm_bond_notifier_lock	ecm_bond_notifier.c	/^static spinlock_t ecm_bond_notifier_lock;			\/* Protect against SMP access between netfilter, events and private threaded function. *\/$/;"	v	file:
ecm_bond_notifier_nss_context	ecm_bond_notifier.c	/^static void *ecm_bond_notifier_nss_context = NULL;		\/* Registration for LAG *\/$/;"	v	file:
ecm_bond_notifier_send_lag_state	ecm_bond_notifier.c	/^static nss_tx_status_t ecm_bond_notifier_send_lag_state(struct nss_ctx_instance *nss_ctx, struct net_device *slave, enum nss_lag_state_change_ev slave_state)$/;"	f	file:
ecm_bond_notifier_set_stop	ecm_bond_notifier.c	/^static ssize_t ecm_bond_notifier_set_stop(struct device *dev,$/;"	f	file:
ecm_bond_notifier_stop	ecm_bond_notifier.c	/^EXPORT_SYMBOL(ecm_bond_notifier_stop);$/;"	v
ecm_bond_notifier_stop	ecm_bond_notifier.c	/^void ecm_bond_notifier_stop(int num)$/;"	f
ecm_bond_notifier_stopped	ecm_bond_notifier.c	/^static int ecm_bond_notifier_stopped = 0;			\/* When non-zero further traffic will not be processed *\/$/;"	v	file:
ecm_bond_notifier_subsys	ecm_bond_notifier.c	/^static struct bus_type ecm_bond_notifier_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_cl_nl_genl_attr_ip	ecm_classifier_nl.h	/^union ecm_cl_nl_genl_attr_ip {$/;"	u
ecm_cl_nl_genl_attr_tuple	ecm_classifier_nl.h	/^struct ecm_cl_nl_genl_attr_tuple {$/;"	s
ecm_cl_nl_genl_attr_tuple_decode	ecm_classifier_nl.c	/^ecm_cl_nl_genl_attr_tuple_decode(struct ecm_cl_nl_genl_attr_tuple *tuple,$/;"	f	file:
ecm_cl_nl_genl_attr_tuple_encode	ecm_classifier_nl.c	/^ecm_cl_nl_genl_attr_tuple_encode(struct ecm_cl_nl_genl_attr_tuple *tuple,$/;"	f	file:
ecm_cl_nl_genl_family	ecm_classifier_nl.c	/^static struct genl_family ecm_cl_nl_genl_family = {$/;"	v	typeref:struct:genl_family	file:
ecm_cl_nl_genl_mcgrp	ecm_classifier_nl.c	/^static struct genl_multicast_group ecm_cl_nl_genl_mcgrp = {$/;"	v	typeref:struct:genl_multicast_group	file:
ecm_cl_nl_genl_ops	ecm_classifier_nl.c	/^static struct genl_ops ecm_cl_nl_genl_ops[] = {$/;"	v	typeref:struct:genl_ops	file:
ecm_cl_nl_genl_policy	ecm_classifier_nl.c	/^ecm_cl_nl_genl_policy[ECM_CL_NL_GENL_ATTR_COUNT] = {$/;"	v	typeref:struct:nla_policy	file:
ecm_classifier_acceleration_mode_t	ecm_classifier.h	/^typedef enum ecm_classifier_acceleration_modes ecm_classifier_acceleration_mode_t;$/;"	t	typeref:enum:ecm_classifier_acceleration_modes
ecm_classifier_acceleration_modes	ecm_classifier.h	/^enum ecm_classifier_acceleration_modes {$/;"	g
ecm_classifier_default_accel_mode	ecm_classifier_default.c	/^static ecm_classifier_acceleration_mode_t ecm_classifier_default_accel_mode = ECM_CLASSIFIER_ACCELERATION_MODE_ACCEL;$/;"	v	file:
ecm_classifier_default_attrs	ecm_classifier_default.c	/^static struct device_attribute *ecm_classifier_default_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_classifier_default_count	ecm_classifier_default.c	/^static int ecm_classifier_default_count = 0;			\/* Tracks number of instances allocated *\/$/;"	v	file:
ecm_classifier_default_deref	ecm_classifier_default.c	/^static int ecm_classifier_default_deref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_default_dev	ecm_classifier_default.c	/^static struct device ecm_classifier_default_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_classifier_default_dev_release	ecm_classifier_default.c	/^static void ecm_classifier_default_dev_release(struct device *dev)$/;"	f	file:
ecm_classifier_default_enabled	ecm_classifier_default.c	/^static bool ecm_classifier_default_enabled = true;		\/* When disabled the qos algorithm will not be applied to skb's *\/$/;"	v	file:
ecm_classifier_default_exit	ecm_classifier_default.c	/^EXPORT_SYMBOL(ecm_classifier_default_exit);$/;"	v
ecm_classifier_default_exit	ecm_classifier_default.c	/^void ecm_classifier_default_exit(void)$/;"	f
ecm_classifier_default_get_accel_mode	ecm_classifier_default.c	/^static ssize_t ecm_classifier_default_get_accel_mode(struct device *dev,$/;"	f	file:
ecm_classifier_default_get_enabled	ecm_classifier_default.c	/^static ssize_t ecm_classifier_default_get_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_default_init	ecm_classifier_default.c	/^EXPORT_SYMBOL(ecm_classifier_default_init);$/;"	v
ecm_classifier_default_init	ecm_classifier_default.c	/^int ecm_classifier_default_init(void)$/;"	f
ecm_classifier_default_instance	ecm_classifier_default.h	/^struct ecm_classifier_default_instance {$/;"	s
ecm_classifier_default_instance_alloc	ecm_classifier_default.c	/^EXPORT_SYMBOL(ecm_classifier_default_instance_alloc);$/;"	v
ecm_classifier_default_instance_alloc	ecm_classifier_default.c	/^struct ecm_classifier_default_instance *ecm_classifier_default_instance_alloc(struct ecm_db_connection_instance *ci, int protocol, ecm_db_direction_t dir, int from_port, int to_port)$/;"	f
ecm_classifier_default_internal_instance	ecm_classifier_default.c	/^struct ecm_classifier_default_internal_instance {$/;"	s	file:
ecm_classifier_default_last_process_response_get	ecm_classifier_default.c	/^static void ecm_classifier_default_last_process_response_get(struct ecm_classifier_instance *aci,$/;"	f	file:
ecm_classifier_default_lock	ecm_classifier_default.c	/^static spinlock_t ecm_classifier_default_lock;			\/* Concurrency control SMP access *\/$/;"	v	file:
ecm_classifier_default_process	ecm_classifier_default.c	/^static void ecm_classifier_default_process(struct ecm_classifier_instance *aci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_classifier_default_process_callback_t	ecm_classifier_default.h	/^typedef void (*ecm_classifier_default_process_callback_t)(struct ecm_classifier_default_instance *dci, ecm_tracker_sender_type_t sender, struct iphdr *ip_hdr, int ip_hdr_len, int ip_total_len, struct sk_buff *skb);$/;"	t
ecm_classifier_default_reclassify	ecm_classifier_default.c	/^static void ecm_classifier_default_reclassify(struct ecm_classifier_instance *aci)$/;"	f	file:
ecm_classifier_default_reclassify_allowed	ecm_classifier_default.c	/^static bool ecm_classifier_default_reclassify_allowed(struct ecm_classifier_instance *aci)$/;"	f	file:
ecm_classifier_default_ref	ecm_classifier_default.c	/^static void ecm_classifier_default_ref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_default_set_accel_mode	ecm_classifier_default.c	/^static ssize_t ecm_classifier_default_set_accel_mode(struct device *dev,$/;"	f	file:
ecm_classifier_default_set_enabled	ecm_classifier_default.c	/^static ssize_t ecm_classifier_default_set_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_default_state_file_instance	ecm_classifier_default.c	/^struct ecm_classifier_default_state_file_instance {$/;"	s	file:
ecm_classifier_default_subsys	ecm_classifier_default.c	/^static struct bus_type ecm_classifier_default_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_classifier_default_sync	ecm_classifier_default.h	/^struct ecm_classifier_default_sync {$/;"	s
ecm_classifier_default_sync_from_v4	ecm_classifier_default.c	/^static void ecm_classifier_default_sync_from_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_default_sync_from_v6	ecm_classifier_default.c	/^static void ecm_classifier_default_sync_from_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_default_sync_to_v4	ecm_classifier_default.c	/^static void ecm_classifier_default_sync_to_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_conn_sync *sync)$/;"	f	file:
ecm_classifier_default_sync_to_v6	ecm_classifier_default.c	/^static void ecm_classifier_default_sync_to_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_conn_sync *sync)$/;"	f	file:
ecm_classifier_default_terminate_pending	ecm_classifier_default.c	/^static bool ecm_classifier_default_terminate_pending = false;	\/* True when the user wants us to terminate *\/$/;"	v	file:
ecm_classifier_default_timer_group_change_callback_t	ecm_classifier_default.h	/^typedef ecm_db_timer_group_t (*ecm_classifier_default_timer_group_change_callback_t)(struct ecm_classifier_default_instance *dci);$/;"	t
ecm_classifier_default_tracker_get_and_ref_callback_t	ecm_classifier_default.h	/^typedef struct ecm_tracker_instance *(*ecm_classifier_default_tracker_get_and_ref_callback_t)(struct ecm_classifier_default_instance *dci);$/;"	t	typeref:struct:ecm_classifier_default_tracker_get_and_ref_callback_t
ecm_classifier_default_type_get	ecm_classifier_default.c	/^static ecm_classifier_type_t ecm_classifier_default_type_get(struct ecm_classifier_instance *aci)$/;"	f	file:
ecm_classifier_default_xml_state_get	ecm_classifier_default.c	/^static int ecm_classifier_default_xml_state_get(struct ecm_classifier_instance *ci, char *buf, int buf_sz)$/;"	f	file:
ecm_classifier_deref_callback_t	ecm_classifier.h	/^typedef int (*ecm_classifier_deref_callback_t)(struct ecm_classifier_instance *ci);$/;"	t
ecm_classifier_dscp_count	ecm_classifier_dscp.c	/^static int ecm_classifier_dscp_count = 0;			\/* Tracks number of instances allocated *\/$/;"	v	file:
ecm_classifier_dscp_deref	ecm_classifier_dscp.c	/^static int ecm_classifier_dscp_deref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_dscp_dev	ecm_classifier_dscp.c	/^static struct device ecm_classifier_dscp_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_classifier_dscp_dev_release	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_dev_release(struct device *dev)$/;"	f	file:
ecm_classifier_dscp_enabled	ecm_classifier_dscp.c	/^static bool ecm_classifier_dscp_enabled = true;			\/* Operational behaviour *\/$/;"	v	file:
ecm_classifier_dscp_exit	ecm_classifier_dscp.c	/^EXPORT_SYMBOL(ecm_classifier_dscp_exit);$/;"	v
ecm_classifier_dscp_exit	ecm_classifier_dscp.c	/^void ecm_classifier_dscp_exit(void)$/;"	f
ecm_classifier_dscp_get_enabled	ecm_classifier_dscp.c	/^static ssize_t ecm_classifier_dscp_get_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_dscp_init	ecm_classifier_dscp.c	/^EXPORT_SYMBOL(ecm_classifier_dscp_init);$/;"	v
ecm_classifier_dscp_init	ecm_classifier_dscp.c	/^int ecm_classifier_dscp_init(void)$/;"	f
ecm_classifier_dscp_instance	ecm_classifier_dscp.c	/^struct ecm_classifier_dscp_instance {$/;"	s	file:
ecm_classifier_dscp_instance_alloc	ecm_classifier_dscp.c	/^EXPORT_SYMBOL(ecm_classifier_dscp_instance_alloc);$/;"	v
ecm_classifier_dscp_instance_alloc	ecm_classifier_dscp.c	/^struct ecm_classifier_dscp_instance *ecm_classifier_dscp_instance_alloc(struct ecm_db_connection_instance *ci)$/;"	f
ecm_classifier_dscp_instances	ecm_classifier_dscp.c	/^static struct ecm_classifier_dscp_instance *ecm_classifier_dscp_instances = NULL;$/;"	v	typeref:struct:ecm_classifier_dscp_instance	file:
ecm_classifier_dscp_last_process_response_get	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_last_process_response_get(struct ecm_classifier_instance *ci,$/;"	f	file:
ecm_classifier_dscp_lock	ecm_classifier_dscp.c	/^static spinlock_t ecm_classifier_dscp_lock;			\/* Protect SMP access. *\/$/;"	v	file:
ecm_classifier_dscp_process	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_process(struct ecm_classifier_instance *aci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_classifier_dscp_reclassify	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_reclassify(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_dscp_reclassify_allowed	ecm_classifier_dscp.c	/^static bool ecm_classifier_dscp_reclassify_allowed(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_dscp_ref	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_ref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_dscp_set_enabled	ecm_classifier_dscp.c	/^static ssize_t ecm_classifier_dscp_set_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_dscp_subsys	ecm_classifier_dscp.c	/^static struct bus_type ecm_classifier_dscp_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_classifier_dscp_sync_from_v4	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_sync_from_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_dscp_sync_from_v6	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_sync_from_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_dscp_sync_to_v4	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_sync_to_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_conn_sync *sync)$/;"	f	file:
ecm_classifier_dscp_sync_to_v6	ecm_classifier_dscp.c	/^static void ecm_classifier_dscp_sync_to_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_conn_sync *sync)$/;"	f	file:
ecm_classifier_dscp_terminate_pending	ecm_classifier_dscp.c	/^static bool ecm_classifier_dscp_terminate_pending = false;	\/* True when the user wants us to terminate *\/$/;"	v	file:
ecm_classifier_dscp_type_get	ecm_classifier_dscp.c	/^static ecm_classifier_type_t ecm_classifier_dscp_type_get(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_dscp_xml_state_get	ecm_classifier_dscp.c	/^static int ecm_classifier_dscp_xml_state_get(struct ecm_classifier_instance *ci, char *buf, int buf_sz)$/;"	f	file:
ecm_classifier_hyfi_attrs	ecm_classifier_hyfi.c	/^static struct device_attribute *ecm_classifier_hyfi_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_classifier_hyfi_connection_added	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_connection_added(void *arg, struct ecm_db_connection_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_connection_removed	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_connection_removed(void *arg, struct ecm_db_connection_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_count	ecm_classifier_hyfi.c	/^static int ecm_classifier_hyfi_count = 0;					\/* Tracks number of instances allocated *\/$/;"	v	file:
ecm_classifier_hyfi_deref	ecm_classifier_hyfi.c	/^static int ecm_classifier_hyfi_deref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_dev	ecm_classifier_hyfi.c	/^static struct device ecm_classifier_hyfi_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_classifier_hyfi_dev_release	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_dev_release(struct device *dev)$/;"	f	file:
ecm_classifier_hyfi_enabled	ecm_classifier_hyfi.c	/^static bool ecm_classifier_hyfi_enabled = true;		\/* Operational behaviour *\/$/;"	v	file:
ecm_classifier_hyfi_instance	ecm_classifier_hyfi.c	/^struct ecm_classifier_hyfi_instance {$/;"	s	file:
ecm_classifier_hyfi_instance_alloc	ecm_classifier_hyfi.c	/^EXPORT_SYMBOL(ecm_classifier_hyfi_instance_alloc);$/;"	v
ecm_classifier_hyfi_instance_alloc	ecm_classifier_hyfi.c	/^struct ecm_classifier_hyfi_instance *ecm_classifier_hyfi_instance_alloc(struct ecm_db_connection_instance *ci)$/;"	f
ecm_classifier_hyfi_instances	ecm_classifier_hyfi.c	/^static struct ecm_classifier_hyfi_instance *ecm_classifier_hyfi_instances = NULL;$/;"	v	typeref:struct:ecm_classifier_hyfi_instance	file:
ecm_classifier_hyfi_last_process_response_get	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_last_process_response_get(struct ecm_classifier_instance *ci,$/;"	f	file:
ecm_classifier_hyfi_li	ecm_classifier_hyfi.c	/^struct ecm_db_listener_instance *ecm_classifier_hyfi_li = NULL;$/;"	v	typeref:struct:ecm_db_listener_instance
ecm_classifier_hyfi_lock	ecm_classifier_hyfi.c	/^static spinlock_t ecm_classifier_hyfi_lock;			\/* Protect SMP access. *\/$/;"	v	file:
ecm_classifier_hyfi_process	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_process(struct ecm_classifier_instance *aci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_classifier_hyfi_reclassify	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_reclassify(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_reclassify_allowed	ecm_classifier_hyfi.c	/^static bool ecm_classifier_hyfi_reclassify_allowed(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_ref	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_ref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_rule_get_enabled	ecm_classifier_hyfi.c	/^static ssize_t ecm_classifier_hyfi_rule_get_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_hyfi_rule_set_enabled	ecm_classifier_hyfi.c	/^static ssize_t ecm_classifier_hyfi_rule_set_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_hyfi_rules_exit	ecm_classifier_hyfi.c	/^EXPORT_SYMBOL(ecm_classifier_hyfi_rules_exit);$/;"	v
ecm_classifier_hyfi_rules_exit	ecm_classifier_hyfi.c	/^void ecm_classifier_hyfi_rules_exit(void)$/;"	f
ecm_classifier_hyfi_rules_init	ecm_classifier_hyfi.c	/^EXPORT_SYMBOL(ecm_classifier_hyfi_rules_init);$/;"	v
ecm_classifier_hyfi_rules_init	ecm_classifier_hyfi.c	/^int ecm_classifier_hyfi_rules_init(void)$/;"	f
ecm_classifier_hyfi_set_command	ecm_classifier_hyfi.c	/^static ssize_t ecm_classifier_hyfi_set_command(struct device *dev,$/;"	f	file:
ecm_classifier_hyfi_subsys	ecm_classifier_hyfi.c	/^static struct bus_type ecm_classifier_hyfi_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_classifier_hyfi_sync_from_v4	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_sync_from_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_hyfi_sync_from_v6	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_sync_from_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_hyfi_sync_to_v4	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_sync_to_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_conn_sync *sync)$/;"	f	file:
ecm_classifier_hyfi_sync_to_v6	ecm_classifier_hyfi.c	/^static void ecm_classifier_hyfi_sync_to_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_conn_sync *sync)$/;"	f	file:
ecm_classifier_hyfi_terminate_pending	ecm_classifier_hyfi.c	/^static bool ecm_classifier_hyfi_terminate_pending = false;		\/* True when the user wants us to terminate *\/$/;"	v	file:
ecm_classifier_hyfi_type_get	ecm_classifier_hyfi.c	/^static ecm_classifier_type_t ecm_classifier_hyfi_type_get(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_hyfi_xml_state_get	ecm_classifier_hyfi.c	/^static int ecm_classifier_hyfi_xml_state_get(struct ecm_classifier_instance *ci, char *buf, int buf_sz)$/;"	f	file:
ecm_classifier_instance	ecm_classifier.h	/^struct ecm_classifier_instance {$/;"	s
ecm_classifier_last_process_response_get_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_last_process_response_get_callback_t)(struct ecm_classifier_instance *ci, struct ecm_classifier_process_response *process_response);$/;"	t
ecm_classifier_nl_attrs	ecm_classifier_nl.c	/^static struct device_attribute *ecm_classifier_nl_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_classifier_nl_connection_added	ecm_classifier_nl.c	/^static void ecm_classifier_nl_connection_added(void *arg, struct ecm_db_connection_instance *ci)$/;"	f	file:
ecm_classifier_nl_connection_removed	ecm_classifier_nl.c	/^static void ecm_classifier_nl_connection_removed(void *arg, struct ecm_db_connection_instance *ci)$/;"	f	file:
ecm_classifier_nl_count	ecm_classifier_nl.c	/^static int ecm_classifier_nl_count = 0;					\/* Tracks number of instances allocated *\/$/;"	v	file:
ecm_classifier_nl_ct_get_and_ref	ecm_classifier_nl.c	/^ecm_classifier_nl_ct_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f	file:
ecm_classifier_nl_deref	ecm_classifier_nl.c	/^static int ecm_classifier_nl_deref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_nl_dev	ecm_classifier_nl.c	/^static struct device ecm_classifier_nl_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_classifier_nl_dev_release	ecm_classifier_nl.c	/^static void ecm_classifier_nl_dev_release(struct device *dev)$/;"	f	file:
ecm_classifier_nl_enabled	ecm_classifier_nl.c	/^static bool ecm_classifier_nl_enabled = false;		\/* Operational behaviour *\/$/;"	v	file:
ecm_classifier_nl_genl_msg_ACCEL	ecm_classifier_nl.c	/^static int ecm_classifier_nl_genl_msg_ACCEL(struct sk_buff *skb,$/;"	f	file:
ecm_classifier_nl_genl_msg_ACCEL_OK	ecm_classifier_nl.c	/^ecm_classifier_nl_genl_msg_ACCEL_OK(struct ecm_classifier_nl_instance *cnli)$/;"	f	file:
ecm_classifier_nl_genl_msg_closed	ecm_classifier_nl.c	/^static void ecm_classifier_nl_genl_msg_closed(struct ecm_classifier_nl_instance *cnli,$/;"	f	file:
ecm_classifier_nl_instance	ecm_classifier_nl.c	/^struct ecm_classifier_nl_instance {$/;"	s	file:
ecm_classifier_nl_instance_alloc	ecm_classifier_nl.c	/^EXPORT_SYMBOL(ecm_classifier_nl_instance_alloc);$/;"	v
ecm_classifier_nl_instance_alloc	ecm_classifier_nl.c	/^struct ecm_classifier_nl_instance *ecm_classifier_nl_instance_alloc(struct ecm_db_connection_instance *ci)$/;"	f
ecm_classifier_nl_instances	ecm_classifier_nl.c	/^static struct ecm_classifier_nl_instance *ecm_classifier_nl_instances = NULL;$/;"	v	typeref:struct:ecm_classifier_nl_instance	file:
ecm_classifier_nl_last_process_response_get	ecm_classifier_nl.c	/^static void ecm_classifier_nl_last_process_response_get(struct ecm_classifier_instance *ci,$/;"	f	file:
ecm_classifier_nl_li	ecm_classifier_nl.c	/^struct ecm_db_listener_instance *ecm_classifier_nl_li = NULL;$/;"	v	typeref:struct:ecm_db_listener_instance
ecm_classifier_nl_lock	ecm_classifier_nl.c	/^static spinlock_t ecm_classifier_nl_lock;			\/* Protect SMP access. *\/$/;"	v	file:
ecm_classifier_nl_process	ecm_classifier_nl.c	/^static void ecm_classifier_nl_process(struct ecm_classifier_instance *aci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_classifier_nl_process_mark	ecm_classifier_nl.c	/^EXPORT_SYMBOL(ecm_classifier_nl_process_mark);$/;"	v
ecm_classifier_nl_process_mark	ecm_classifier_nl.c	/^ecm_classifier_nl_process_mark(struct ecm_classifier_nl_instance *cnli,$/;"	f
ecm_classifier_nl_reclassify	ecm_classifier_nl.c	/^static void ecm_classifier_nl_reclassify(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_nl_reclassify_allowed	ecm_classifier_nl.c	/^static bool ecm_classifier_nl_reclassify_allowed(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_nl_ref	ecm_classifier_nl.c	/^static void ecm_classifier_nl_ref(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_nl_register_genl	ecm_classifier_nl.c	/^static int ecm_classifier_nl_register_genl(void)$/;"	f	file:
ecm_classifier_nl_rule_get_enabled	ecm_classifier_nl.c	/^static ssize_t ecm_classifier_nl_rule_get_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_nl_rule_set_enabled	ecm_classifier_nl.c	/^static ssize_t ecm_classifier_nl_rule_set_enabled(struct device *dev,$/;"	f	file:
ecm_classifier_nl_rules_exit	ecm_classifier_nl.c	/^EXPORT_SYMBOL(ecm_classifier_nl_rules_exit);$/;"	v
ecm_classifier_nl_rules_exit	ecm_classifier_nl.c	/^void ecm_classifier_nl_rules_exit(void)$/;"	f
ecm_classifier_nl_rules_init	ecm_classifier_nl.c	/^EXPORT_SYMBOL(ecm_classifier_nl_rules_init);$/;"	v
ecm_classifier_nl_rules_init	ecm_classifier_nl.c	/^int ecm_classifier_nl_rules_init(void)$/;"	f
ecm_classifier_nl_send_genl_msg	ecm_classifier_nl.c	/^ecm_classifier_nl_send_genl_msg(enum ECM_CL_NL_GENL_CMD cmd,$/;"	f	file:
ecm_classifier_nl_set_command	ecm_classifier_nl.c	/^static ssize_t ecm_classifier_nl_set_command(struct device *dev,$/;"	f	file:
ecm_classifier_nl_subsys	ecm_classifier_nl.c	/^static struct bus_type ecm_classifier_nl_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_classifier_nl_sync_from_v4	ecm_classifier_nl.c	/^static void ecm_classifier_nl_sync_from_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_nl_sync_from_v6	ecm_classifier_nl.c	/^static void ecm_classifier_nl_sync_from_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_rule_create_msg *nircm)$/;"	f	file:
ecm_classifier_nl_sync_to_v4	ecm_classifier_nl.c	/^static void ecm_classifier_nl_sync_to_v4(struct ecm_classifier_instance *aci, struct nss_ipv4_conn_sync *sync)$/;"	f	file:
ecm_classifier_nl_sync_to_v6	ecm_classifier_nl.c	/^static void ecm_classifier_nl_sync_to_v6(struct ecm_classifier_instance *aci, struct nss_ipv6_conn_sync *sync)$/;"	f	file:
ecm_classifier_nl_terminate_pending	ecm_classifier_nl.c	/^static bool ecm_classifier_nl_terminate_pending = false;		\/* True when the user wants us to terminate *\/$/;"	v	file:
ecm_classifier_nl_type_get	ecm_classifier_nl.c	/^static ecm_classifier_type_t ecm_classifier_nl_type_get(struct ecm_classifier_instance *ci)$/;"	f	file:
ecm_classifier_nl_unregister_genl	ecm_classifier_nl.c	/^static void ecm_classifier_nl_unregister_genl(void)$/;"	f	file:
ecm_classifier_nl_xml_state_get	ecm_classifier_nl.c	/^static int ecm_classifier_nl_xml_state_get(struct ecm_classifier_instance *ci, char *buf, int buf_sz)$/;"	f	file:
ecm_classifier_process_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_process_callback_t)(struct ecm_classifier_instance *ci, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb, struct ecm_classifier_process_response *process_response);$/;"	t
ecm_classifier_process_response	ecm_classifier.h	/^struct ecm_classifier_process_response {$/;"	s
ecm_classifier_process_response_xml_state_get	ecm_classifier.h	/^static inline int ecm_classifier_process_response_xml_state_get(char *buf, int buf_sz, struct ecm_classifier_process_response *pr)$/;"	f
ecm_classifier_reclassify_allowed_get_callback_t	ecm_classifier.h	/^typedef bool (*ecm_classifier_reclassify_allowed_get_callback_t)(struct ecm_classifier_instance *ci);$/;"	t
ecm_classifier_reclassify_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_reclassify_callback_t)(struct ecm_classifier_instance *ci);$/;"	t
ecm_classifier_ref_method_t	ecm_classifier.h	/^typedef void (*ecm_classifier_ref_method_t)(struct ecm_classifier_instance *ci);$/;"	t
ecm_classifier_relevances	ecm_classifier.h	/^enum ecm_classifier_relevances {$/;"	g
ecm_classifier_relevence_t	ecm_classifier.h	/^typedef enum ecm_classifier_relevances ecm_classifier_relevence_t;$/;"	t	typeref:enum:ecm_classifier_relevances
ecm_classifier_sync_from_v4_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_sync_from_v4_callback_t)(struct ecm_classifier_instance *ci, struct nss_ipv4_rule_create_msg *nircm);$/;"	t
ecm_classifier_sync_from_v6_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_sync_from_v6_callback_t)(struct ecm_classifier_instance *ci, struct nss_ipv6_rule_create_msg *nircm);$/;"	t
ecm_classifier_sync_to_v4_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_sync_to_v4_callback_t)(struct ecm_classifier_instance *ci, struct nss_ipv4_conn_sync *sync);$/;"	t
ecm_classifier_sync_to_v6_callback_t	ecm_classifier.h	/^typedef void (*ecm_classifier_sync_to_v6_callback_t)(struct ecm_classifier_instance *ci, struct nss_ipv6_conn_sync *sync);$/;"	t
ecm_classifier_tracker_get_and_ref	ecm_classifier_default.c	/^static struct ecm_tracker_instance *ecm_classifier_tracker_get_and_ref(struct ecm_classifier_default_instance *dci)$/;"	f	file:
ecm_classifier_type_get_callback_t	ecm_classifier.h	/^typedef ecm_classifier_type_t (*ecm_classifier_type_get_callback_t)(struct ecm_classifier_instance *ci);$/;"	t
ecm_classifier_type_t	ecm_classifier.h	/^typedef enum ecm_classifier_types ecm_classifier_type_t;$/;"	t	typeref:enum:ecm_classifier_types
ecm_classifier_types	ecm_classifier.h	/^enum ecm_classifier_types {$/;"	g
ecm_classifier_xml_state_get_callback_t	ecm_classifier.h	/^typedef int (*ecm_classifier_xml_state_get_callback_t)(struct ecm_classifier_instance *ci, char *buf, int buf_sz);$/;"	t
ecm_conntrack_event	ecm_conntrack_notifier.c	/^static int ecm_conntrack_event(struct notifier_block *this, unsigned long events, void *ptr)$/;"	f	file:
ecm_conntrack_notifier	ecm_conntrack_notifier.c	/^static struct nf_ct_event_notifier ecm_conntrack_notifier = {$/;"	v	typeref:struct:nf_ct_event_notifier	file:
ecm_conntrack_notifier	ecm_conntrack_notifier.c	/^static struct notifier_block ecm_conntrack_notifier = {$/;"	v	typeref:struct:notifier_block	file:
ecm_conntrack_notifier_dev	ecm_conntrack_notifier.c	/^static struct device ecm_conntrack_notifier_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_conntrack_notifier_dev_release	ecm_conntrack_notifier.c	/^static void ecm_conntrack_notifier_dev_release(struct device *dev)$/;"	f	file:
ecm_conntrack_notifier_exit	ecm_conntrack_notifier.c	/^EXPORT_SYMBOL(ecm_conntrack_notifier_exit);$/;"	v
ecm_conntrack_notifier_exit	ecm_conntrack_notifier.c	/^void ecm_conntrack_notifier_exit(void)$/;"	f
ecm_conntrack_notifier_get_stop	ecm_conntrack_notifier.c	/^static ssize_t ecm_conntrack_notifier_get_stop(struct device *dev,$/;"	f	file:
ecm_conntrack_notifier_init	ecm_conntrack_notifier.c	/^EXPORT_SYMBOL(ecm_conntrack_notifier_init);$/;"	v
ecm_conntrack_notifier_init	ecm_conntrack_notifier.c	/^int ecm_conntrack_notifier_init(void)$/;"	f
ecm_conntrack_notifier_lock	ecm_conntrack_notifier.c	/^static spinlock_t ecm_conntrack_notifier_lock;				\/* Protect against SMP access between netfilter, events and private threaded function. *\/$/;"	v	file:
ecm_conntrack_notifier_set_stop	ecm_conntrack_notifier.c	/^static ssize_t ecm_conntrack_notifier_set_stop(struct device *dev,$/;"	f	file:
ecm_conntrack_notifier_stop	ecm_conntrack_notifier.c	/^EXPORT_SYMBOL(ecm_conntrack_notifier_stop);$/;"	v
ecm_conntrack_notifier_stop	ecm_conntrack_notifier.c	/^void ecm_conntrack_notifier_stop(int num)$/;"	f
ecm_conntrack_notifier_stopped	ecm_conntrack_notifier.c	/^static int ecm_conntrack_notifier_stopped = 0;				\/* When non-zero further traffic will not be processed *\/$/;"	v	file:
ecm_conntrack_notifier_subsys	ecm_conntrack_notifier.c	/^static struct bus_type ecm_conntrack_notifier_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_db_attrs	ecm_db.c	/^static struct device_attribute *ecm_db_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_db_char_dev_conn_chain_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_conn_chain_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_conn_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_conn_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_cta_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_cta_msg_prep(struct ecm_db_state_file_instance *sfi, ecm_classifier_type_t ca_type)$/;"	f	file:
ecm_db_char_dev_host_chain_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_host_chain_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_host_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_host_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_iface_chain_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_iface_chain_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_iface_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_iface_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_mapping_chain_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_mapping_chain_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_mapping_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_mapping_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_node_chain_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_node_chain_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_node_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_node_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_dev_protocol_count_msg_prep	ecm_db.c	/^static bool ecm_db_char_dev_protocol_count_msg_prep(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_char_device_open	ecm_db.c	/^static int ecm_db_char_device_open(struct inode *inode, struct file *file)$/;"	f	file:
ecm_db_char_device_read	ecm_db.c	/^static ssize_t ecm_db_char_device_read(struct file *file,	\/* see include\/linux\/fs.h   *\/$/;"	f	file:
ecm_db_char_device_release	ecm_db.c	/^static int ecm_db_char_device_release(struct inode *inode, struct file *file)$/;"	f	file:
ecm_db_char_device_write	ecm_db.c	/^static ssize_t ecm_db_char_device_write(struct file *filp, const char *buff, size_t len, loff_t * off)$/;"	f	file:
ecm_db_classifier_generation	ecm_db.c	/^static uint16_t ecm_db_classifier_generation = 0;		\/* Generation counter to detect out of date connections that should be reclassified *\/$/;"	v	file:
ecm_db_classifier_generation_change	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_classifier_generation_change);$/;"	v
ecm_db_classifier_generation_change	ecm_db.c	/^void ecm_db_classifier_generation_change(void)$/;"	f
ecm_db_connection_add	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_add);$/;"	v
ecm_db_connection_add	ecm_db.c	/^void ecm_db_connection_add(struct ecm_db_connection_instance *ci,$/;"	f
ecm_db_connection_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_alloc);$/;"	v
ecm_db_connection_alloc	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_alloc(void)$/;"	f
ecm_db_connection_assigned_classifier_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_assigned_classifier_find_and_ref);$/;"	v
ecm_db_connection_assigned_classifier_find_and_ref	ecm_db.c	/^struct ecm_classifier_instance *ecm_db_connection_assigned_classifier_find_and_ref(struct ecm_db_connection_instance *ci, ecm_classifier_type_t type)$/;"	f
ecm_db_connection_assignments_release	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_assignments_release);$/;"	v
ecm_db_connection_assignments_release	ecm_db.c	/^void ecm_db_connection_assignments_release(int assignment_count, struct ecm_classifier_instance *assignments[])$/;"	f
ecm_db_connection_by_classifier_type_assignment_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_by_classifier_type_assignment_deref);$/;"	v
ecm_db_connection_by_classifier_type_assignment_deref	ecm_db.c	/^void ecm_db_connection_by_classifier_type_assignment_deref(struct ecm_db_connection_instance *ci, ecm_classifier_type_t ca_type)$/;"	f
ecm_db_connection_by_classifier_type_assignment_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_by_classifier_type_assignment_get_and_ref_first);$/;"	v
ecm_db_connection_by_classifier_type_assignment_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_by_classifier_type_assignment_get_and_ref_first(ecm_classifier_type_t ca_type)$/;"	f
ecm_db_connection_by_classifier_type_assignment_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_by_classifier_type_assignment_get_and_ref_next);$/;"	v
ecm_db_connection_by_classifier_type_assignment_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_by_classifier_type_assignment_get_and_ref_next(struct ecm_db_connection_instance *ci, ecm_classifier_type_t ca_type)$/;"	f
ecm_db_connection_classifier_assign	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_assign);$/;"	v
ecm_db_connection_classifier_assign	ecm_db.c	/^void ecm_db_connection_classifier_assign(struct ecm_db_connection_instance *ci, struct ecm_classifier_instance *new_ca)$/;"	f
ecm_db_connection_classifier_assignments_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_assignments_get_and_ref);$/;"	v
ecm_db_connection_classifier_assignments_get_and_ref	ecm_db.c	/^int ecm_db_connection_classifier_assignments_get_and_ref(struct ecm_db_connection_instance *ci, struct ecm_classifier_instance *assignments[])$/;"	f
ecm_db_connection_classifier_default_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_default_get_and_ref);$/;"	v
ecm_db_connection_classifier_default_get_and_ref	ecm_db.c	/^struct ecm_classifier_default_instance *ecm_db_connection_classifier_default_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_classifier_generation_change	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_generation_change);$/;"	v
ecm_db_connection_classifier_generation_change	ecm_db.c	/^void ecm_db_connection_classifier_generation_change(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_classifier_generation_changed	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_generation_changed);$/;"	v
ecm_db_connection_classifier_generation_changed	ecm_db.c	/^bool ecm_db_connection_classifier_generation_changed(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_classifier_peek_generation_changed	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_peek_generation_changed);$/;"	v
ecm_db_connection_classifier_peek_generation_changed	ecm_db.c	/^bool ecm_db_connection_classifier_peek_generation_changed(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_classifier_type_assignment	ecm_db.c	/^struct ecm_db_connection_classifier_type_assignment {$/;"	s	file:
ecm_db_connection_classifier_type_assignment_list	ecm_db.c	/^struct ecm_db_connection_classifier_type_assignment_list {$/;"	s	file:
ecm_db_connection_classifier_type_assignments	ecm_db.c	/^} ecm_db_connection_classifier_type_assignments[ECM_CLASSIFIER_TYPES];$/;"	v	typeref:struct:ecm_db_connection_classifier_type_assignment_list
ecm_db_connection_classifier_unassign	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_classifier_unassign);$/;"	v
ecm_db_connection_classifier_unassign	ecm_db.c	/^void ecm_db_connection_classifier_unassign(struct ecm_db_connection_instance *ci, struct ecm_classifier_instance *cci)$/;"	f
ecm_db_connection_count	ecm_db.c	/^static int ecm_db_connection_count = 0;		\/* Number of connections allocated *\/$/;"	v	file:
ecm_db_connection_count_by_protocol	ecm_db.c	/^static int ecm_db_connection_count_by_protocol[256];		\/* Each IP protocol has its own count *\/$/;"	v	file:
ecm_db_connection_count_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_count_get);$/;"	v
ecm_db_connection_count_get	ecm_db.c	/^int ecm_db_connection_count_get(void)$/;"	f
ecm_db_connection_data_stats_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_data_stats_get);$/;"	v
ecm_db_connection_data_stats_get	ecm_db.c	/^void ecm_db_connection_data_stats_get(struct ecm_db_connection_instance *ci, uint64_t *from_data_total, uint64_t *to_data_total,$/;"	f
ecm_db_connection_data_totals_update	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_data_totals_update);$/;"	v
ecm_db_connection_data_totals_update	ecm_db.c	/^void ecm_db_connection_data_totals_update(struct ecm_db_connection_instance *ci, bool is_from, uint64_t size, uint64_t packets)$/;"	f
ecm_db_connection_data_totals_update_dropped	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_data_totals_update_dropped);$/;"	v
ecm_db_connection_data_totals_update_dropped	ecm_db.c	/^void ecm_db_connection_data_totals_update_dropped(struct ecm_db_connection_instance *ci, bool is_from, uint64_t size, uint64_t packets)$/;"	f
ecm_db_connection_defunct_all	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_defunct_all);$/;"	v
ecm_db_connection_defunct_all	ecm_db.c	/^void ecm_db_connection_defunct_all(void)$/;"	f
ecm_db_connection_defunct_callback	ecm_db.c	/^static void ecm_db_connection_defunct_callback(void *arg)$/;"	f	file:
ecm_db_connection_defunct_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_connection_defunct_callback_t)(void *arg);	\/* Defunct callback *\/$/;"	t
ecm_db_connection_defunct_timer_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_defunct_timer_reset);$/;"	v
ecm_db_connection_defunct_timer_reset	ecm_db.c	/^bool ecm_db_connection_defunct_timer_reset(struct ecm_db_connection_instance *ci, ecm_db_timer_group_t tg)$/;"	f
ecm_db_connection_defunct_timer_touch	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_defunct_timer_touch);$/;"	v
ecm_db_connection_defunct_timer_touch	ecm_db.c	/^bool ecm_db_connection_defunct_timer_touch(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_deref);$/;"	v
ecm_db_connection_deref	ecm_db.c	/^int ecm_db_connection_deref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_direction_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_direction_get);$/;"	v
ecm_db_connection_direction_get	ecm_db.c	/^ecm_db_direction_t ecm_db_connection_direction_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_connection_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_connection_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_find_and_ref);$/;"	v
ecm_db_connection_find_and_ref	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_find_and_ref(ip_addr_t host1_addr, ip_addr_t host2_addr, int protocol, int host1_port, int host2_port)$/;"	f
ecm_db_connection_from_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_address_get);$/;"	v
ecm_db_connection_from_address_get	ecm_db.c	/^void ecm_db_connection_from_address_get(struct ecm_db_connection_instance *ci, ip_addr_t addr)$/;"	f
ecm_db_connection_from_address_nat_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_address_nat_get);$/;"	v
ecm_db_connection_from_address_nat_get	ecm_db.c	/^void ecm_db_connection_from_address_nat_get(struct ecm_db_connection_instance *ci, ip_addr_t addr)$/;"	f
ecm_db_connection_from_iface_mtu_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_iface_mtu_get);$/;"	v
ecm_db_connection_from_iface_mtu_get	ecm_db.c	/^int ecm_db_connection_from_iface_mtu_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_iface_name_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_iface_name_get);$/;"	v
ecm_db_connection_from_iface_name_get	ecm_db.c	/^void ecm_db_connection_from_iface_name_get(struct ecm_db_connection_instance *ci, char *name_buffer)$/;"	f
ecm_db_connection_from_iface_type_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_iface_type_get);$/;"	v
ecm_db_connection_from_iface_type_get	ecm_db.c	/^ecm_db_iface_type_t ecm_db_connection_from_iface_type_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_interfaces_clear	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_interfaces_clear);$/;"	v
ecm_db_connection_from_interfaces_clear	ecm_db.c	/^void ecm_db_connection_from_interfaces_clear(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_interfaces_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_interfaces_get_and_ref);$/;"	v
ecm_db_connection_from_interfaces_get_and_ref	ecm_db.c	/^int32_t ecm_db_connection_from_interfaces_get_and_ref(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[])$/;"	f
ecm_db_connection_from_interfaces_get_count	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_interfaces_get_count);$/;"	v
ecm_db_connection_from_interfaces_get_count	ecm_db.c	/^int32_t ecm_db_connection_from_interfaces_get_count(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_interfaces_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_interfaces_reset);$/;"	v
ecm_db_connection_from_interfaces_reset	ecm_db.c	/^void ecm_db_connection_from_interfaces_reset(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[], int32_t new_first)$/;"	f
ecm_db_connection_from_interfaces_set_check	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_interfaces_set_check);$/;"	v
ecm_db_connection_from_interfaces_set_check	ecm_db.c	/^bool ecm_db_connection_from_interfaces_set_check(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_nat_interfaces_clear	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_interfaces_clear);$/;"	v
ecm_db_connection_from_nat_interfaces_clear	ecm_db.c	/^void ecm_db_connection_from_nat_interfaces_clear(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_nat_interfaces_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_interfaces_get_and_ref);$/;"	v
ecm_db_connection_from_nat_interfaces_get_and_ref	ecm_db.c	/^int32_t ecm_db_connection_from_nat_interfaces_get_and_ref(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[])$/;"	f
ecm_db_connection_from_nat_interfaces_get_count	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_interfaces_get_count);$/;"	v
ecm_db_connection_from_nat_interfaces_get_count	ecm_db.c	/^int32_t ecm_db_connection_from_nat_interfaces_get_count(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_nat_interfaces_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_interfaces_reset);$/;"	v
ecm_db_connection_from_nat_interfaces_reset	ecm_db.c	/^void ecm_db_connection_from_nat_interfaces_reset(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[], int32_t new_first)$/;"	f
ecm_db_connection_from_nat_interfaces_set_check	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_interfaces_set_check);$/;"	v
ecm_db_connection_from_nat_interfaces_set_check	ecm_db.c	/^bool ecm_db_connection_from_nat_interfaces_set_check(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_nat_node_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_nat_node_address_get);$/;"	v
ecm_db_connection_from_nat_node_address_get	ecm_db.c	/^void ecm_db_connection_from_nat_node_address_get(struct ecm_db_connection_instance *ci, uint8_t *address_buffer)$/;"	f
ecm_db_connection_from_node_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_node_address_get);$/;"	v
ecm_db_connection_from_node_address_get	ecm_db.c	/^void ecm_db_connection_from_node_address_get(struct ecm_db_connection_instance *ci, uint8_t *address_buffer)$/;"	f
ecm_db_connection_from_port_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_port_get);$/;"	v
ecm_db_connection_from_port_get	ecm_db.c	/^int ecm_db_connection_from_port_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_from_port_nat_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_from_port_nat_get);$/;"	v
ecm_db_connection_from_port_nat_get	ecm_db.c	/^int ecm_db_connection_from_port_nat_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_front_end_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_front_end_get_and_ref);$/;"	v
ecm_db_connection_front_end_get_and_ref	ecm_db.c	/^struct ecm_front_end_connection_instance *ecm_db_connection_front_end_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_generate_hash_index	ecm_db.c	/^static inline ecm_db_connection_hash_t ecm_db_connection_generate_hash_index(ip_addr_t host1_addr, uint32_t host1_port, ip_addr_t host2_addr, uint32_t host2_port, int protocol)$/;"	f	file:
ecm_db_connection_generate_serial_hash_index	ecm_db.c	/^static inline ecm_db_connection_serial_hash_t ecm_db_connection_generate_serial_hash_index(uint32_t serial)$/;"	f	file:
ecm_db_connection_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_get_and_ref_next);$/;"	v
ecm_db_connection_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_connection_hash_t;$/;"	t	file:
ecm_db_connection_heirarchy_xml_state_get	ecm_db.c	/^static int ecm_db_connection_heirarchy_xml_state_get(char *element, struct ecm_db_iface_instance *interfaces[], int32_t first_interface,$/;"	f	file:
ecm_db_connection_iface_from_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_iface_from_get_and_ref_next);$/;"	v
ecm_db_connection_iface_from_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_iface_from_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_iface_nat_from_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_iface_nat_from_get_and_ref_next);$/;"	v
ecm_db_connection_iface_nat_from_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_iface_nat_from_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_iface_nat_to_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_iface_nat_to_get_and_ref_next);$/;"	v
ecm_db_connection_iface_nat_to_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_iface_nat_to_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_iface_to_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_iface_to_get_and_ref_next);$/;"	v
ecm_db_connection_iface_to_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_iface_to_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_iface_type_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_iface_type_get);$/;"	v
ecm_db_connection_iface_type_get	ecm_db.c	/^ecm_db_iface_type_t ecm_db_connection_iface_type_get(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_connection_instance	ecm_db.c	/^struct ecm_db_connection_instance {$/;"	s	file:
ecm_db_connection_interfaces_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_interfaces_deref);$/;"	v
ecm_db_connection_interfaces_deref	ecm_db.c	/^void ecm_db_connection_interfaces_deref(struct ecm_db_iface_instance *interfaces[], int32_t first)$/;"	f
ecm_db_connection_is_routed_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_is_routed_get);$/;"	v
ecm_db_connection_is_routed_get	ecm_db.c	/^bool ecm_db_connection_is_routed_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_listener_added_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_connection_listener_added_callback_t)(void *arg, struct ecm_db_connection_instance *ci);	\/* Connection added callback *\/$/;"	t
ecm_db_connection_listener_removed_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_connection_listener_removed_callback_t)(void *arg, struct ecm_db_connection_instance *ci);	\/* Connection removed callback *\/$/;"	t
ecm_db_connection_make_defunct	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_make_defunct);$/;"	v
ecm_db_connection_make_defunct	ecm_db.c	/^void ecm_db_connection_make_defunct(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_make_defunct_by_assignment_type	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_make_defunct_by_assignment_type);$/;"	v
ecm_db_connection_make_defunct_by_assignment_type	ecm_db.c	/^void ecm_db_connection_make_defunct_by_assignment_type(ecm_classifier_type_t ca_type)$/;"	f
ecm_db_connection_mapping_from_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_from_get_and_ref);$/;"	v
ecm_db_connection_mapping_from_get_and_ref	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_connection_mapping_from_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_from_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_from_get_and_ref_next);$/;"	v
ecm_db_connection_mapping_from_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_mapping_from_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_nat_from_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_nat_from_get_and_ref);$/;"	v
ecm_db_connection_mapping_nat_from_get_and_ref	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_connection_mapping_nat_from_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_nat_from_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_nat_from_get_and_ref_next);$/;"	v
ecm_db_connection_mapping_nat_from_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_mapping_nat_from_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_nat_to_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_nat_to_get_and_ref);$/;"	v
ecm_db_connection_mapping_nat_to_get_and_ref	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_connection_mapping_nat_to_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_nat_to_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_nat_to_get_and_ref_next);$/;"	v
ecm_db_connection_mapping_nat_to_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_mapping_nat_to_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_to_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_to_get_and_ref);$/;"	v
ecm_db_connection_mapping_to_get_and_ref	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_connection_mapping_to_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_mapping_to_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_mapping_to_get_and_ref_next);$/;"	v
ecm_db_connection_mapping_to_get_and_ref_next	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_mapping_to_get_and_ref_next(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_node_from_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_node_from_get_and_ref);$/;"	v
ecm_db_connection_node_from_get_and_ref	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_connection_node_from_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_node_to_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_node_to_get_and_ref);$/;"	v
ecm_db_connection_node_to_get_and_ref	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_connection_node_to_get_and_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_protocol_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_protocol_get);$/;"	v
ecm_db_connection_protocol_get	ecm_db.c	/^int ecm_db_connection_protocol_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_ref);$/;"	v
ecm_db_connection_ref	ecm_db.c	/^void ecm_db_connection_ref(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_regenerate_by_assignment_type	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_regenerate_by_assignment_type);$/;"	v
ecm_db_connection_regenerate_by_assignment_type	ecm_db.c	/^void ecm_db_connection_regenerate_by_assignment_type(ecm_classifier_type_t ca_type)$/;"	f
ecm_db_connection_serial	ecm_db.c	/^static int ecm_db_connection_serial = 0;	\/* Serial number - ensures each connection has a unique serial number.$/;"	v	file:
ecm_db_connection_serial_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_serial_find_and_ref);$/;"	v
ecm_db_connection_serial_find_and_ref	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connection_serial_find_and_ref(uint32_t serial)$/;"	f
ecm_db_connection_serial_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_serial_get);$/;"	v
ecm_db_connection_serial_get	ecm_db.c	/^uint32_t ecm_db_connection_serial_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_serial_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_connection_serial_hash_t;$/;"	t	file:
ecm_db_connection_serial_table	ecm_db.c	/^static struct ecm_db_connection_instance *ecm_db_connection_serial_table[ECM_DB_CONNECTION_SERIAL_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_connection_instance	file:
ecm_db_connection_serial_table_lengths	ecm_db.c	/^static int ecm_db_connection_serial_table_lengths[ECM_DB_CONNECTION_SERIAL_HASH_SLOTS];$/;"	v	file:
ecm_db_connection_table	ecm_db.c	/^static struct ecm_db_connection_instance *ecm_db_connection_table[ECM_DB_CONNECTION_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_connection_instance	file:
ecm_db_connection_table_lengths	ecm_db.c	/^static int ecm_db_connection_table_lengths[ECM_DB_CONNECTION_HASH_SLOTS];$/;"	v	file:
ecm_db_connection_timer_group_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_timer_group_get);$/;"	v
ecm_db_connection_timer_group_get	ecm_db.c	/^ecm_db_timer_group_t ecm_db_connection_timer_group_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_address_get);$/;"	v
ecm_db_connection_to_address_get	ecm_db.c	/^void ecm_db_connection_to_address_get(struct ecm_db_connection_instance *ci, ip_addr_t addr)$/;"	f
ecm_db_connection_to_address_nat_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_address_nat_get);$/;"	v
ecm_db_connection_to_address_nat_get	ecm_db.c	/^void ecm_db_connection_to_address_nat_get(struct ecm_db_connection_instance *ci, ip_addr_t addr)$/;"	f
ecm_db_connection_to_iface_mtu_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_iface_mtu_get);$/;"	v
ecm_db_connection_to_iface_mtu_get	ecm_db.c	/^int ecm_db_connection_to_iface_mtu_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_iface_name_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_iface_name_get);$/;"	v
ecm_db_connection_to_iface_name_get	ecm_db.c	/^void ecm_db_connection_to_iface_name_get(struct ecm_db_connection_instance *ci, char *name_buffer)$/;"	f
ecm_db_connection_to_iface_type_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_iface_type_get);$/;"	v
ecm_db_connection_to_iface_type_get	ecm_db.c	/^ecm_db_iface_type_t ecm_db_connection_to_iface_type_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_interfaces_clear	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_interfaces_clear);$/;"	v
ecm_db_connection_to_interfaces_clear	ecm_db.c	/^void ecm_db_connection_to_interfaces_clear(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_interfaces_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_interfaces_get_and_ref);$/;"	v
ecm_db_connection_to_interfaces_get_and_ref	ecm_db.c	/^int32_t ecm_db_connection_to_interfaces_get_and_ref(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[])$/;"	f
ecm_db_connection_to_interfaces_get_count	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_interfaces_get_count);$/;"	v
ecm_db_connection_to_interfaces_get_count	ecm_db.c	/^int32_t ecm_db_connection_to_interfaces_get_count(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_interfaces_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_interfaces_reset);$/;"	v
ecm_db_connection_to_interfaces_reset	ecm_db.c	/^void ecm_db_connection_to_interfaces_reset(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[], int32_t new_first)$/;"	f
ecm_db_connection_to_interfaces_set_check	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_interfaces_set_check);$/;"	v
ecm_db_connection_to_interfaces_set_check	ecm_db.c	/^bool ecm_db_connection_to_interfaces_set_check(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_nat_interfaces_clear	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_interfaces_clear);$/;"	v
ecm_db_connection_to_nat_interfaces_clear	ecm_db.c	/^void ecm_db_connection_to_nat_interfaces_clear(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_nat_interfaces_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_interfaces_get_and_ref);$/;"	v
ecm_db_connection_to_nat_interfaces_get_and_ref	ecm_db.c	/^int32_t ecm_db_connection_to_nat_interfaces_get_and_ref(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[])$/;"	f
ecm_db_connection_to_nat_interfaces_get_count	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_interfaces_get_count);$/;"	v
ecm_db_connection_to_nat_interfaces_get_count	ecm_db.c	/^int32_t ecm_db_connection_to_nat_interfaces_get_count(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_nat_interfaces_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_interfaces_reset);$/;"	v
ecm_db_connection_to_nat_interfaces_reset	ecm_db.c	/^void ecm_db_connection_to_nat_interfaces_reset(struct ecm_db_connection_instance *ci, struct ecm_db_iface_instance *interfaces[], int32_t new_first)$/;"	f
ecm_db_connection_to_nat_interfaces_set_check	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_interfaces_set_check);$/;"	v
ecm_db_connection_to_nat_interfaces_set_check	ecm_db.c	/^bool ecm_db_connection_to_nat_interfaces_set_check(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_nat_node_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_nat_node_address_get);$/;"	v
ecm_db_connection_to_nat_node_address_get	ecm_db.c	/^void ecm_db_connection_to_nat_node_address_get(struct ecm_db_connection_instance *ci, uint8_t *address_buffer)$/;"	f
ecm_db_connection_to_node_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_node_address_get);$/;"	v
ecm_db_connection_to_node_address_get	ecm_db.c	/^void ecm_db_connection_to_node_address_get(struct ecm_db_connection_instance *ci, uint8_t *address_buffer)$/;"	f
ecm_db_connection_to_port_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_port_get);$/;"	v
ecm_db_connection_to_port_get	ecm_db.c	/^int ecm_db_connection_to_port_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connection_to_port_nat_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connection_to_port_nat_get);$/;"	v
ecm_db_connection_to_port_nat_get	ecm_db.c	/^int ecm_db_connection_to_port_nat_get(struct ecm_db_connection_instance *ci)$/;"	f
ecm_db_connections	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_connections = NULL;$/;"	v	typeref:struct:ecm_db_connection_instance
ecm_db_connections_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_connections_get_and_ref_first);$/;"	v
ecm_db_connections_get_and_ref_first	ecm_db.c	/^static struct ecm_db_connection_instance *ecm_db_connections_get_and_ref_first(void)$/;"	f	file:
ecm_db_dev	ecm_db.c	/^static struct device ecm_db_dev;				\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_db_dev_major_id	ecm_db.c	/^static int ecm_db_dev_major_id = 0;			\/* Major ID of registered char dev from which we can dump out state to userspace *\/$/;"	v	file:
ecm_db_dev_release	ecm_db.c	/^static void ecm_db_dev_release(struct device *dev)$/;"	f	file:
ecm_db_direction_t	ecm_db_types.h	/^typedef enum ecm_db_directions ecm_db_direction_t;$/;"	t	typeref:enum:ecm_db_directions
ecm_db_directions	ecm_db_types.h	/^enum ecm_db_directions {$/;"	g
ecm_db_exit	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_exit);$/;"	v
ecm_db_exit	ecm_db.c	/^void ecm_db_exit(void)$/;"	f
ecm_db_fops	ecm_db.c	/^static struct file_operations ecm_db_fops = {$/;"	v	typeref:struct:file_operations	file:
ecm_db_get_connection_count	ecm_db.c	/^static ssize_t ecm_db_get_connection_count(struct device *dev,$/;"	f	file:
ecm_db_get_connection_counts_simple	ecm_db.c	/^static ssize_t ecm_db_get_connection_counts_simple(struct device *dev,$/;"	f	file:
ecm_db_get_defunct_all	ecm_db.c	/^static ssize_t ecm_db_get_defunct_all(struct device *dev,$/;"	f	file:
ecm_db_get_host_count	ecm_db.c	/^static ssize_t ecm_db_get_host_count(struct device *dev,$/;"	f	file:
ecm_db_get_iface_count	ecm_db.c	/^static ssize_t ecm_db_get_iface_count(struct device *dev,$/;"	f	file:
ecm_db_get_mapping_count	ecm_db.c	/^static ssize_t ecm_db_get_mapping_count(struct device *dev,$/;"	f	file:
ecm_db_get_node_count	ecm_db.c	/^static ssize_t ecm_db_get_node_count(struct device *dev,$/;"	f	file:
ecm_db_get_state_dev_major	ecm_db.c	/^static ssize_t ecm_db_get_state_dev_major(struct device *dev,$/;"	f	file:
ecm_db_get_state_file_output_mask	ecm_db.c	/^static ssize_t ecm_db_get_state_file_output_mask(struct device *dev,$/;"	f	file:
ecm_db_host_add	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_add);$/;"	v
ecm_db_host_add	ecm_db.c	/^void ecm_db_host_add(struct ecm_db_host_instance *hi, ip_addr_t address, bool on_link, ecm_db_host_final_callback_t final, void *arg)$/;"	f
ecm_db_host_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_address_get);$/;"	v
ecm_db_host_address_get	ecm_db.c	/^void ecm_db_host_address_get(struct ecm_db_host_instance *hi, ip_addr_t addr)$/;"	f
ecm_db_host_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_alloc);$/;"	v
ecm_db_host_alloc	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_host_alloc(void)$/;"	f
ecm_db_host_count	ecm_db.c	/^static int ecm_db_host_count = 0;			\/* Number of hosts allocated *\/$/;"	v	file:
ecm_db_host_data_stats_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_data_stats_get);$/;"	v
ecm_db_host_data_stats_get	ecm_db.c	/^void ecm_db_host_data_stats_get(struct ecm_db_host_instance *hi, uint64_t *from_data_total, uint64_t *to_data_total,$/;"	f
ecm_db_host_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_deref);$/;"	v
ecm_db_host_deref	ecm_db.c	/^int ecm_db_host_deref(struct ecm_db_host_instance *hi)$/;"	f
ecm_db_host_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_host_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_host_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_find_and_ref);$/;"	v
ecm_db_host_find_and_ref	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_host_find_and_ref(ip_addr_t address)$/;"	f
ecm_db_host_generate_hash_index	ecm_db.c	/^static inline ecm_db_host_hash_t ecm_db_host_generate_hash_index(ip_addr_t address)$/;"	f	file:
ecm_db_host_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_get_and_ref_next);$/;"	v
ecm_db_host_get_and_ref_next	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_host_get_and_ref_next(struct ecm_db_host_instance *hi)$/;"	f
ecm_db_host_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_host_hash_t;$/;"	t	file:
ecm_db_host_instance	ecm_db.c	/^struct ecm_db_host_instance {$/;"	s	file:
ecm_db_host_listener_added_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_host_listener_added_callback_t)(void *arg, struct ecm_db_host_instance *hi);		\/* Added callback *\/$/;"	t
ecm_db_host_listener_removed_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_host_listener_removed_callback_t)(void *arg, struct ecm_db_host_instance *hi);		\/* Removed callback *\/$/;"	t
ecm_db_host_mapping_count_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_mapping_count_get);$/;"	v
ecm_db_host_mapping_count_get	ecm_db.c	/^int ecm_db_host_mapping_count_get(struct ecm_db_host_instance *hi)$/;"	f
ecm_db_host_on_link_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_on_link_get);$/;"	v
ecm_db_host_on_link_get	ecm_db.c	/^bool ecm_db_host_on_link_get(struct ecm_db_host_instance *hi)$/;"	f
ecm_db_host_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_host_ref);$/;"	v
ecm_db_host_ref	ecm_db.c	/^void ecm_db_host_ref(struct ecm_db_host_instance *hi)$/;"	f
ecm_db_host_table	ecm_db.c	/^static struct ecm_db_host_instance *ecm_db_host_table[ECM_DB_HOST_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_host_instance	file:
ecm_db_host_table_lengths	ecm_db.c	/^static int ecm_db_host_table_lengths[ECM_DB_HOST_HASH_SLOTS];$/;"	v	file:
ecm_db_hosts	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_hosts = NULL;$/;"	v	typeref:struct:ecm_db_host_instance
ecm_db_hosts_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_hosts_get_and_ref_first);$/;"	v
ecm_db_hosts_get_and_ref_first	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_hosts_get_and_ref_first(void)$/;"	f
ecm_db_iface_add_bridge	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_bridge);$/;"	v
ecm_db_iface_add_bridge	ecm_db.c	/^void ecm_db_iface_add_bridge(struct ecm_db_iface_instance *ii, uint8_t *address, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_ethernet	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_ethernet);$/;"	v
ecm_db_iface_add_ethernet	ecm_db.c	/^void ecm_db_iface_add_ethernet(struct ecm_db_iface_instance *ii, uint8_t *address, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_ipsec_tunnel	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_ipsec_tunnel);$/;"	v
ecm_db_iface_add_ipsec_tunnel	ecm_db.c	/^void ecm_db_iface_add_ipsec_tunnel(struct ecm_db_iface_instance *ii, uint32_t os_specific_ident, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_lag	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_lag);$/;"	v
ecm_db_iface_add_lag	ecm_db.c	/^void ecm_db_iface_add_lag(struct ecm_db_iface_instance *ii, uint8_t *address, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_loopback	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_loopback);$/;"	v
ecm_db_iface_add_loopback	ecm_db.c	/^void ecm_db_iface_add_loopback(struct ecm_db_iface_instance *ii, uint32_t os_specific_ident, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_pppoe	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_pppoe);$/;"	v
ecm_db_iface_add_pppoe	ecm_db.c	/^void ecm_db_iface_add_pppoe(struct ecm_db_iface_instance *ii, uint16_t pppoe_session_id, uint8_t *remote_mac,$/;"	f
ecm_db_iface_add_sit	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_sit);$/;"	v
ecm_db_iface_add_sit	ecm_db.c	/^void ecm_db_iface_add_sit(struct ecm_db_iface_instance *ii, struct ecm_db_interface_info_sit *type_info, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_tunipip6	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_tunipip6);$/;"	v
ecm_db_iface_add_tunipip6	ecm_db.c	/^void ecm_db_iface_add_tunipip6(struct ecm_db_iface_instance *ii, struct ecm_db_interface_info_tunipip6 *type_info, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_unknown	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_unknown);$/;"	v
ecm_db_iface_add_unknown	ecm_db.c	/^void ecm_db_iface_add_unknown(struct ecm_db_iface_instance *ii, uint32_t os_specific_ident, char *name, int32_t mtu,$/;"	f
ecm_db_iface_add_vlan	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_add_vlan);$/;"	v
ecm_db_iface_add_vlan	ecm_db.c	/^void ecm_db_iface_add_vlan(struct ecm_db_iface_instance *ii, uint8_t *address, uint16_t vlan_tag, uint16_t vlan_tpid, char *name, int32_t mtu,$/;"	f
ecm_db_iface_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_alloc);$/;"	v
ecm_db_iface_alloc	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_alloc(void)$/;"	f
ecm_db_iface_bridge_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_bridge_address_get);$/;"	v
ecm_db_iface_bridge_address_get	ecm_db.c	/^void ecm_db_iface_bridge_address_get(struct ecm_db_iface_instance *ii, uint8_t *address)$/;"	f
ecm_db_iface_bridge_xml_state_get	ecm_db.c	/^static int ecm_db_iface_bridge_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_connections_from_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_connections_from_get_and_ref_first);$/;"	v
ecm_db_iface_connections_from_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_iface_connections_from_get_and_ref_first(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_connections_nat_from_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_connections_nat_from_get_and_ref_first);$/;"	v
ecm_db_iface_connections_nat_from_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_iface_connections_nat_from_get_and_ref_first(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_connections_nat_to_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_connections_nat_to_get_and_ref_first);$/;"	v
ecm_db_iface_connections_nat_to_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_iface_connections_nat_to_get_and_ref_first(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_connections_to_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_connections_to_get_and_ref_first);$/;"	v
ecm_db_iface_connections_to_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_iface_connections_to_get_and_ref_first(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_count	ecm_db.c	/^static int ecm_db_iface_count = 0;			\/* Number of interfaces allocated *\/$/;"	v	file:
ecm_db_iface_data_stats_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_data_stats_get);$/;"	v
ecm_db_iface_data_stats_get	ecm_db.c	/^void ecm_db_iface_data_stats_get(struct ecm_db_iface_instance *ii, uint64_t *from_data_total, uint64_t *to_data_total,$/;"	f
ecm_db_iface_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_deref);$/;"	v
ecm_db_iface_deref	ecm_db.c	/^int ecm_db_iface_deref(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_ethernet_address_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_ethernet_address_get);$/;"	v
ecm_db_iface_ethernet_address_get	ecm_db.c	/^void ecm_db_iface_ethernet_address_get(struct ecm_db_iface_instance *ii, uint8_t *address)$/;"	f
ecm_db_iface_ethernet_xml_state_get	ecm_db.c	/^static int ecm_db_iface_ethernet_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_iface_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_iface_find_and_ref_bridge	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_bridge);$/;"	v
ecm_db_iface_find_and_ref_bridge	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_bridge(uint8_t *address)$/;"	f
ecm_db_iface_find_and_ref_ipsec_tunnel	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_ipsec_tunnel);$/;"	v
ecm_db_iface_find_and_ref_ipsec_tunnel	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_ipsec_tunnel(uint32_t os_specific_ident)$/;"	f
ecm_db_iface_find_and_ref_lag	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_lag);$/;"	v
ecm_db_iface_find_and_ref_lag	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_lag(uint8_t *address)$/;"	f
ecm_db_iface_find_and_ref_loopback	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_loopback);$/;"	v
ecm_db_iface_find_and_ref_loopback	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_loopback(uint32_t os_specific_ident)$/;"	f
ecm_db_iface_find_and_ref_pppoe	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_pppoe);$/;"	v
ecm_db_iface_find_and_ref_pppoe	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_pppoe(uint16_t pppoe_session_id, uint8_t *remote_mac)$/;"	f
ecm_db_iface_find_and_ref_sit	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_sit);$/;"	v
ecm_db_iface_find_and_ref_sit	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_sit(ip_addr_t saddr, ip_addr_t daddr)$/;"	f
ecm_db_iface_find_and_ref_tunipip6	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_tunipip6);$/;"	v
ecm_db_iface_find_and_ref_tunipip6	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_tunipip6(ip_addr_t saddr, ip_addr_t daddr)$/;"	f
ecm_db_iface_find_and_ref_unknown	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_unknown);$/;"	v
ecm_db_iface_find_and_ref_unknown	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_unknown(uint32_t os_specific_ident)$/;"	f
ecm_db_iface_find_and_ref_vlan	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_find_and_ref_vlan);$/;"	v
ecm_db_iface_find_and_ref_vlan	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_find_and_ref_vlan(uint8_t *address, uint16_t vlan_tag, uint16_t vlan_tpid)$/;"	f
ecm_db_iface_generate_hash_index_ethernet	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_ethernet(uint8_t *address)$/;"	f	file:
ecm_db_iface_generate_hash_index_ipsec_tunnel	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_ipsec_tunnel(uint32_t os_specific_ident)$/;"	f	file:
ecm_db_iface_generate_hash_index_loopback	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_loopback(uint32_t os_specific_ident)$/;"	f	file:
ecm_db_iface_generate_hash_index_pppoe	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_pppoe(uint16_t pppoe_session_id)$/;"	f	file:
ecm_db_iface_generate_hash_index_sit	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_sit(ip_addr_t saddr, ip_addr_t daddr)$/;"	f	file:
ecm_db_iface_generate_hash_index_tunipip6	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_tunipip6(ip_addr_t saddr, ip_addr_t daddr)$/;"	f	file:
ecm_db_iface_generate_hash_index_unknown	ecm_db.c	/^static inline ecm_db_iface_hash_t ecm_db_iface_generate_hash_index_unknown(uint32_t os_specific_ident)$/;"	f	file:
ecm_db_iface_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_iface_hash_t;$/;"	t	file:
ecm_db_iface_ifidx_find_and_ref_ethernet	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_ifidx_find_and_ref_ethernet);$/;"	v
ecm_db_iface_ifidx_find_and_ref_ethernet	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_iface_ifidx_find_and_ref_ethernet(uint8_t *address, int32_t ifidx)$/;"	f
ecm_db_iface_instance	ecm_db.c	/^struct ecm_db_iface_instance {$/;"	s	file:
ecm_db_iface_interface_identifier_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_interface_identifier_get);$/;"	v
ecm_db_iface_interface_identifier_get	ecm_db.c	/^int32_t ecm_db_iface_interface_identifier_get(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_ipsec_tunnel_xml_state_get	ecm_db.c	/^static int ecm_db_iface_ipsec_tunnel_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_lag_xml_state_get	ecm_db.c	/^static int ecm_db_iface_lag_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_listener_added_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_iface_listener_added_callback_t)(void *arg, struct ecm_db_iface_instance *ii);		\/* Added callback *\/$/;"	t
ecm_db_iface_listener_removed_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_iface_listener_removed_callback_t)(void *arg, struct ecm_db_iface_instance *ii);		\/* Removed callback *\/$/;"	t
ecm_db_iface_loopback_xml_state_get	ecm_db.c	/^static int ecm_db_iface_loopback_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_mtu_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_mtu_reset);$/;"	v
ecm_db_iface_mtu_reset	ecm_db.c	/^int32_t ecm_db_iface_mtu_reset(struct ecm_db_iface_instance *ii, int32_t mtu)$/;"	f
ecm_db_iface_node_count_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_node_count_get);$/;"	v
ecm_db_iface_node_count_get	ecm_db.c	/^int ecm_db_iface_node_count_get(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_nodes_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_nodes_get_and_ref_first);$/;"	v
ecm_db_iface_nodes_get_and_ref_first	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_iface_nodes_get_and_ref_first(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_nss_interface_identifier_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_nss_interface_identifier_get);$/;"	v
ecm_db_iface_nss_interface_identifier_get	ecm_db.c	/^int32_t ecm_db_iface_nss_interface_identifier_get(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_pppoe_session_info_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_pppoe_session_info_get);$/;"	v
ecm_db_iface_pppoe_session_info_get	ecm_db.c	/^void ecm_db_iface_pppoe_session_info_get(struct ecm_db_iface_instance *ii, struct ecm_db_interface_info_pppoe *pppoe_info)$/;"	f
ecm_db_iface_pppoe_xml_state_get	ecm_db.c	/^static int ecm_db_iface_pppoe_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_ref);$/;"	v
ecm_db_iface_ref	ecm_db.c	/^void ecm_db_iface_ref(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_sit_daddr_is_null	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_sit_daddr_is_null);$/;"	v
ecm_db_iface_sit_daddr_is_null	ecm_db.c	/^bool ecm_db_iface_sit_daddr_is_null(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_iface_table	ecm_db.c	/^static struct ecm_db_iface_instance *ecm_db_iface_table[ECM_DB_IFACE_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_iface_instance	file:
ecm_db_iface_table_lengths	ecm_db.c	/^static int ecm_db_iface_table_lengths[ECM_DB_IFACE_HASH_SLOTS];$/;"	v	file:
ecm_db_iface_type_t	ecm_db_types.h	/^typedef enum ecm_db_iface_types ecm_db_iface_type_t;$/;"	t	typeref:enum:ecm_db_iface_types
ecm_db_iface_types	ecm_db_types.h	/^enum ecm_db_iface_types {$/;"	g
ecm_db_iface_unknown_xml_state_get	ecm_db.c	/^static int ecm_db_iface_unknown_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_vlan_info_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_iface_vlan_info_get);$/;"	v
ecm_db_iface_vlan_info_get	ecm_db.c	/^void ecm_db_iface_vlan_info_get(struct ecm_db_iface_instance *ii, struct ecm_db_interface_info_vlan *vlan_info)$/;"	f
ecm_db_iface_vlan_xml_state_get	ecm_db.c	/^static int ecm_db_iface_vlan_xml_state_get(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_xml_state_get_close	ecm_db.c	/^static int ecm_db_iface_xml_state_get_close(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_iface_xml_state_get_method_t	ecm_db.c	/^typedef int (*ecm_db_iface_xml_state_get_method_t)(struct ecm_db_iface_instance *ii, char *buf, int buf_sz);$/;"	t	file:
ecm_db_iface_xml_state_get_open	ecm_db.c	/^static int ecm_db_iface_xml_state_get_open(struct ecm_db_iface_instance *ii, char *buf, int buf_sz)$/;"	f	file:
ecm_db_init	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_init);$/;"	v
ecm_db_init	ecm_db.c	/^int ecm_db_init(void)$/;"	f
ecm_db_interface_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_interface_get_and_ref_next);$/;"	v
ecm_db_interface_get_and_ref_next	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_interface_get_and_ref_next(struct ecm_db_iface_instance *ii)$/;"	f
ecm_db_interface_info_bridge	ecm_db_types.h	/^struct ecm_db_interface_info_bridge {			\/* type == ECM_DB_IFACE_TYPE_BRIDGE *\/$/;"	s
ecm_db_interface_info_ethernet	ecm_db_types.h	/^struct ecm_db_interface_info_ethernet {			\/* type == ECM_DB_IFACE_TYPE_ETHERNET *\/$/;"	s
ecm_db_interface_info_ipsec_tunnel	ecm_db_types.h	/^struct ecm_db_interface_info_ipsec_tunnel {		\/* type == ECM_DB_IFACE_TYPE_IPSEC_TUNNEL *\/$/;"	s
ecm_db_interface_info_lag	ecm_db_types.h	/^struct ecm_db_interface_info_lag {			\/* type == ECM_DB_IFACE_TYPE_LAG *\/$/;"	s
ecm_db_interface_info_loopback	ecm_db_types.h	/^struct ecm_db_interface_info_loopback {			\/* type == ECM_DB_IFACE_TYPE_LOOPBACK *\/$/;"	s
ecm_db_interface_info_pppoe	ecm_db_types.h	/^struct ecm_db_interface_info_pppoe {			\/* type == ECM_DB_IFACE_TYPE_PPPOE *\/$/;"	s
ecm_db_interface_info_sit	ecm_db_types.h	/^struct ecm_db_interface_info_sit {			\/* type == ECM_DB_IFACE_TYPE_SIT *\/$/;"	s
ecm_db_interface_info_tunipip6	ecm_db_types.h	/^struct ecm_db_interface_info_tunipip6 {			\/* type == ECM_DB_IFACE_TYPE_TUNIPIP6 *\/$/;"	s
ecm_db_interface_info_unknown	ecm_db_types.h	/^struct ecm_db_interface_info_unknown {			\/* type == ECM_DB_IFACE_TYPE_UNKNOWN *\/$/;"	s
ecm_db_interface_info_vlan	ecm_db_types.h	/^struct ecm_db_interface_info_vlan {			\/* type == ECM_DB_IFACE_TYPE_VLAN *\/$/;"	s
ecm_db_interface_type_names	ecm_db.c	/^static char *ecm_db_interface_type_names[ECM_DB_IFACE_TYPE_COUNT] = {$/;"	v	file:
ecm_db_interface_type_to_string	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_interface_type_to_string);$/;"	v
ecm_db_interface_type_to_string	ecm_db.c	/^char *ecm_db_interface_type_to_string(ecm_db_iface_type_t type)$/;"	f
ecm_db_interfaces	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_interfaces = NULL;$/;"	v	typeref:struct:ecm_db_iface_instance
ecm_db_interfaces_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_interfaces_get_and_ref_first);$/;"	v
ecm_db_interfaces_get_and_ref_first	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_interfaces_get_and_ref_first(void)$/;"	f
ecm_db_listener_add	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_listener_add);$/;"	v
ecm_db_listener_add	ecm_db.c	/^void ecm_db_listener_add(struct ecm_db_listener_instance *li,$/;"	f
ecm_db_listener_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_listener_alloc);$/;"	v
ecm_db_listener_alloc	ecm_db.c	/^struct ecm_db_listener_instance *ecm_db_listener_alloc(void)$/;"	f
ecm_db_listener_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_listener_deref);$/;"	v
ecm_db_listener_deref	ecm_db.c	/^int ecm_db_listener_deref(struct ecm_db_listener_instance *li)$/;"	f
ecm_db_listener_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_listener_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_listener_get_and_ref_next	ecm_db.c	/^static struct ecm_db_listener_instance *ecm_db_listener_get_and_ref_next(struct ecm_db_listener_instance *li)$/;"	f	file:
ecm_db_listener_instance	ecm_db.c	/^struct ecm_db_listener_instance {$/;"	s	file:
ecm_db_listener_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_listener_ref);$/;"	v
ecm_db_listener_ref	ecm_db.c	/^void ecm_db_listener_ref(struct ecm_db_listener_instance *li)$/;"	f
ecm_db_listeners	ecm_db.c	/^static struct ecm_db_listener_instance *ecm_db_listeners = NULL;$/;"	v	typeref:struct:ecm_db_listener_instance	file:
ecm_db_listeners_count	ecm_db.c	/^static int ecm_db_listeners_count = 0;			\/* Number of listeners allocated *\/$/;"	v	file:
ecm_db_listeners_get_and_ref_first	ecm_db.c	/^static struct ecm_db_listener_instance *ecm_db_listeners_get_and_ref_first(void)$/;"	f	file:
ecm_db_lock	ecm_db.c	/^static spinlock_t ecm_db_lock;					\/* Protect the table from SMP access. *\/$/;"	v	file:
ecm_db_mapping_add	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_add);$/;"	v
ecm_db_mapping_add	ecm_db.c	/^void ecm_db_mapping_add(struct ecm_db_mapping_instance *mi, struct ecm_db_host_instance *hi, int port,$/;"	f
ecm_db_mapping_adress_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_adress_get);$/;"	v
ecm_db_mapping_adress_get	ecm_db.c	/^void ecm_db_mapping_adress_get(struct ecm_db_mapping_instance *mi, ip_addr_t addr)$/;"	f
ecm_db_mapping_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_alloc);$/;"	v
ecm_db_mapping_alloc	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_mapping_alloc(void)$/;"	f
ecm_db_mapping_connections_from_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_connections_from_get_and_ref_first);$/;"	v
ecm_db_mapping_connections_from_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_mapping_connections_from_get_and_ref_first(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_connections_nat_from_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_connections_nat_from_get_and_ref_first);$/;"	v
ecm_db_mapping_connections_nat_from_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_mapping_connections_nat_from_get_and_ref_first(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_connections_nat_to_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_connections_nat_to_get_and_ref_first);$/;"	v
ecm_db_mapping_connections_nat_to_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_mapping_connections_nat_to_get_and_ref_first(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_connections_to_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_connections_to_get_and_ref_first);$/;"	v
ecm_db_mapping_connections_to_get_and_ref_first	ecm_db.c	/^struct ecm_db_connection_instance *ecm_db_mapping_connections_to_get_and_ref_first(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_connections_total_count_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_connections_total_count_get);$/;"	v
ecm_db_mapping_connections_total_count_get	ecm_db.c	/^int ecm_db_mapping_connections_total_count_get(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_count	ecm_db.c	/^static int ecm_db_mapping_count = 0;			\/* Number of mappings allocated *\/$/;"	v	file:
ecm_db_mapping_data_stats_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_data_stats_get);$/;"	v
ecm_db_mapping_data_stats_get	ecm_db.c	/^void ecm_db_mapping_data_stats_get(struct ecm_db_mapping_instance *mi, uint64_t *from_data_total, uint64_t *to_data_total,$/;"	f
ecm_db_mapping_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_deref);$/;"	v
ecm_db_mapping_deref	ecm_db.c	/^int ecm_db_mapping_deref(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_mapping_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_mapping_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_find_and_ref);$/;"	v
ecm_db_mapping_find_and_ref	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_mapping_find_and_ref(ip_addr_t address, int port)$/;"	f
ecm_db_mapping_generate_hash_index	ecm_db.c	/^static inline ecm_db_mapping_hash_t ecm_db_mapping_generate_hash_index(ip_addr_t address, uint32_t port)$/;"	f	file:
ecm_db_mapping_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_get_and_ref_next);$/;"	v
ecm_db_mapping_get_and_ref_next	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_mapping_get_and_ref_next(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_mapping_hash_t;$/;"	t	file:
ecm_db_mapping_host_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_host_get_and_ref);$/;"	v
ecm_db_mapping_host_get_and_ref	ecm_db.c	/^struct ecm_db_host_instance *ecm_db_mapping_host_get_and_ref(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_instance	ecm_db.c	/^struct ecm_db_mapping_instance {$/;"	s	file:
ecm_db_mapping_listener_added_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_mapping_listener_added_callback_t)(void *arg, struct ecm_db_mapping_instance *mi);		\/* Added callback *\/$/;"	t
ecm_db_mapping_listener_removed_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_mapping_listener_removed_callback_t)(void *arg, struct ecm_db_mapping_instance *mi);	\/* Removed callback *\/$/;"	t
ecm_db_mapping_port_count_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_port_count_get);$/;"	v
ecm_db_mapping_port_count_get	ecm_db.c	/^void ecm_db_mapping_port_count_get(struct ecm_db_mapping_instance *mi,$/;"	f
ecm_db_mapping_port_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_port_get);$/;"	v
ecm_db_mapping_port_get	ecm_db.c	/^int ecm_db_mapping_port_get(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mapping_ref);$/;"	v
ecm_db_mapping_ref	ecm_db.c	/^void ecm_db_mapping_ref(struct ecm_db_mapping_instance *mi)$/;"	f
ecm_db_mapping_table	ecm_db.c	/^static struct ecm_db_mapping_instance *ecm_db_mapping_table[ECM_DB_MAPPING_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_mapping_instance	file:
ecm_db_mapping_table_lengths	ecm_db.c	/^static int ecm_db_mapping_table_lengths[ECM_DB_MAPPING_HASH_SLOTS];$/;"	v	file:
ecm_db_mappings	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_mappings = NULL;$/;"	v	typeref:struct:ecm_db_mapping_instance
ecm_db_mappings_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_mappings_get_and_ref_first);$/;"	v
ecm_db_mappings_get_and_ref_first	ecm_db.c	/^struct ecm_db_mapping_instance *ecm_db_mappings_get_and_ref_first(void)$/;"	f
ecm_db_node_add	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_add);$/;"	v
ecm_db_node_add	ecm_db.c	/^void ecm_db_node_add(struct ecm_db_node_instance *ni, struct ecm_db_iface_instance *ii, uint8_t *address,$/;"	f
ecm_db_node_adress_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_adress_get);$/;"	v
ecm_db_node_adress_get	ecm_db.c	/^void ecm_db_node_adress_get(struct ecm_db_node_instance *ni, uint8_t *address_buffer)$/;"	f
ecm_db_node_alloc	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_alloc);$/;"	v
ecm_db_node_alloc	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_node_alloc(void)$/;"	f
ecm_db_node_count	ecm_db.c	/^static int ecm_db_node_count = 0;			\/* Number of nodes allocated *\/$/;"	v	file:
ecm_db_node_data_stats_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_data_stats_get);$/;"	v
ecm_db_node_data_stats_get	ecm_db.c	/^void ecm_db_node_data_stats_get(struct ecm_db_node_instance *ni, uint64_t *from_data_total, uint64_t *to_data_total,$/;"	f
ecm_db_node_deref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_deref);$/;"	v
ecm_db_node_deref	ecm_db.c	/^int ecm_db_node_deref(struct ecm_db_node_instance *ni)$/;"	f
ecm_db_node_final_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_node_final_callback_t)(void *arg);		\/* Finaliser callback *\/$/;"	t
ecm_db_node_find_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_find_and_ref);$/;"	v
ecm_db_node_find_and_ref	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_node_find_and_ref(uint8_t *address)$/;"	f
ecm_db_node_generate_hash_index	ecm_db.c	/^static inline ecm_db_node_hash_t ecm_db_node_generate_hash_index(uint8_t *address)$/;"	f	file:
ecm_db_node_get_and_ref_next	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_get_and_ref_next);$/;"	v
ecm_db_node_get_and_ref_next	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_node_get_and_ref_next(struct ecm_db_node_instance *ni)$/;"	f
ecm_db_node_hash_t	ecm_db.c	/^typedef uint32_t ecm_db_node_hash_t;$/;"	t	file:
ecm_db_node_iface_get_and_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_iface_get_and_ref);$/;"	v
ecm_db_node_iface_get_and_ref	ecm_db.c	/^struct ecm_db_iface_instance *ecm_db_node_iface_get_and_ref(struct ecm_db_node_instance *ni)$/;"	f
ecm_db_node_instance	ecm_db.c	/^struct ecm_db_node_instance {$/;"	s	file:
ecm_db_node_listener_added_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_node_listener_added_callback_t)(void *arg, struct ecm_db_node_instance *ni);		\/* Added callback *\/$/;"	t
ecm_db_node_listener_removed_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_node_listener_removed_callback_t)(void *arg, struct ecm_db_node_instance *ni);		\/* Removed callback *\/$/;"	t
ecm_db_node_ref	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_node_ref);$/;"	v
ecm_db_node_ref	ecm_db.c	/^void ecm_db_node_ref(struct ecm_db_node_instance *ni)$/;"	f
ecm_db_node_table	ecm_db.c	/^static struct ecm_db_node_instance *ecm_db_node_table[ECM_DB_NODE_HASH_SLOTS];$/;"	v	typeref:struct:ecm_db_node_instance	file:
ecm_db_node_table_lengths	ecm_db.c	/^static int ecm_db_node_table_lengths[ECM_DB_NODE_HASH_SLOTS];$/;"	v	file:
ecm_db_nodes	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_nodes = NULL;$/;"	v	typeref:struct:ecm_db_node_instance
ecm_db_nodes_get_and_ref_first	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_nodes_get_and_ref_first);$/;"	v
ecm_db_nodes_get_and_ref_first	ecm_db.c	/^struct ecm_db_node_instance *ecm_db_nodes_get_and_ref_first(void)$/;"	f
ecm_db_set_defunct_all	ecm_db.c	/^static ssize_t ecm_db_set_defunct_all(struct device *dev,$/;"	f	file:
ecm_db_set_state_file_output_mask	ecm_db.c	/^static ssize_t ecm_db_set_state_file_output_mask(struct device *dev,$/;"	f	file:
ecm_db_state_file_classifier_type_assignments_release	ecm_db.c	/^static void ecm_db_state_file_classifier_type_assignments_release(struct ecm_db_state_file_instance *sfi)$/;"	f	file:
ecm_db_state_file_instance	ecm_db.c	/^struct ecm_db_state_file_instance {$/;"	s	file:
ecm_db_state_file_output_mask	ecm_db.c	/^static int ecm_db_state_file_output_mask = ECM_DB_STATE_FILE_OUTPUT_CONNECTIONS;$/;"	v	file:
ecm_db_subsys	ecm_db.c	/^static struct bus_type ecm_db_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_db_terminate_pending	ecm_db.c	/^static bool ecm_db_terminate_pending = false;			\/* When true the user has requested termination *\/$/;"	v	file:
ecm_db_time	ecm_db.c	/^static uint32_t ecm_db_time = 0;					\/* Time in seconds since start *\/$/;"	v	file:
ecm_db_time_get	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_time_get);$/;"	v
ecm_db_time_get	ecm_db.c	/^uint32_t ecm_db_time_get(void)$/;"	f
ecm_db_timer	ecm_db.c	/^static struct timer_list ecm_db_timer;				\/* Timer to drive timer groups *\/$/;"	v	typeref:struct:timer_list	file:
ecm_db_timer_callback	ecm_db.c	/^static void ecm_db_timer_callback(unsigned long data)$/;"	f	file:
ecm_db_timer_group	ecm_db.c	/^struct ecm_db_timer_group {$/;"	s	file:
ecm_db_timer_group_entry	ecm_db_types.h	/^struct ecm_db_timer_group_entry {$/;"	s
ecm_db_timer_group_entry_callback_t	ecm_db_types.h	/^typedef void (*ecm_db_timer_group_entry_callback_t)(void *arg);	\/* Timer entry has expired *\/$/;"	t
ecm_db_timer_group_entry_init	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_timer_group_entry_init);$/;"	v
ecm_db_timer_group_entry_init	ecm_db.c	/^void ecm_db_timer_group_entry_init(struct ecm_db_timer_group_entry *tge, ecm_db_timer_group_entry_callback_t fn, void *arg)$/;"	f
ecm_db_timer_group_entry_remove	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_timer_group_entry_remove);$/;"	v
ecm_db_timer_group_entry_remove	ecm_db.c	/^bool ecm_db_timer_group_entry_remove(struct ecm_db_timer_group_entry *tge)$/;"	f
ecm_db_timer_group_entry_reset	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_timer_group_entry_reset);$/;"	v
ecm_db_timer_group_entry_reset	ecm_db.c	/^bool ecm_db_timer_group_entry_reset(struct ecm_db_timer_group_entry *tge, ecm_db_timer_group_t tg)$/;"	f
ecm_db_timer_group_entry_set	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_timer_group_entry_set);$/;"	v
ecm_db_timer_group_entry_set	ecm_db.c	/^void ecm_db_timer_group_entry_set(struct ecm_db_timer_group_entry *tge, ecm_db_timer_group_t tg)$/;"	f
ecm_db_timer_group_entry_touch	ecm_db.c	/^EXPORT_SYMBOL(ecm_db_timer_group_entry_touch);$/;"	v
ecm_db_timer_group_entry_touch	ecm_db.c	/^bool ecm_db_timer_group_entry_touch(struct ecm_db_timer_group_entry *tge)$/;"	f
ecm_db_timer_group_t	ecm_db_types.h	/^typedef enum ecm_db_timer_groups ecm_db_timer_group_t;$/;"	t	typeref:enum:ecm_db_timer_groups
ecm_db_timer_groups	ecm_db.c	/^static struct ecm_db_timer_group ecm_db_timer_groups[ECM_DB_TIMER_GROUPS_MAX];$/;"	v	typeref:struct:ecm_db_timer_group	file:
ecm_db_timer_groups	ecm_db_types.h	/^enum ecm_db_timer_groups {$/;"	g
ecm_db_timer_groups_check	ecm_db.c	/^static uint32_t ecm_db_timer_groups_check(uint32_t time_now)$/;"	f	file:
ecm_exit	ecm_init.c	/^static void __exit ecm_exit(void)$/;"	f	file:
ecm_front_end_acceleration_mode_t	ecm_front_end_types.h	/^typedef enum ecm_front_end_acceleration_modes ecm_front_end_acceleration_mode_t;$/;"	t	typeref:enum:ecm_front_end_acceleration_modes
ecm_front_end_acceleration_modes	ecm_front_end_types.h	/^enum ecm_front_end_acceleration_modes {$/;"	g
ecm_front_end_connection_accel_ceased_method_t	ecm_front_end_types.h	/^typedef void (*ecm_front_end_connection_accel_ceased_method_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_accel_state_get_method_t	ecm_front_end_types.h	/^typedef ecm_front_end_acceleration_mode_t (*ecm_front_end_connection_accel_state_get_method_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_action_seen_method_t	ecm_front_end_types.h	/^typedef void (*ecm_front_end_connection_action_seen_method_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_decelerate_method_t	ecm_front_end_types.h	/^typedef void (*ecm_front_end_connection_decelerate_method_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_deref_callback_t	ecm_front_end_types.h	/^typedef int (*ecm_front_end_connection_deref_callback_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_instance	ecm_front_end_types.h	/^struct ecm_front_end_connection_instance {$/;"	s
ecm_front_end_connection_mode_stats	ecm_front_end_types.h	/^struct ecm_front_end_connection_mode_stats {$/;"	s
ecm_front_end_connection_ref_method_t	ecm_front_end_types.h	/^typedef void (*ecm_front_end_connection_ref_method_t)(struct ecm_front_end_connection_instance *feci);$/;"	t
ecm_front_end_connection_xml_state_get_callback_t	ecm_front_end_types.h	/^typedef int (*ecm_front_end_connection_xml_state_get_callback_t)(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz);$/;"	t
ecm_front_end_ipv4_accelerated_count	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_accelerated_count = 0;			\/* Total offloads *\/$/;"	v	file:
ecm_front_end_ipv4_assign_classifier	ecm_front_end_ipv4.c	/^static struct ecm_classifier_instance *ecm_front_end_ipv4_assign_classifier(struct ecm_db_connection_instance *ci, ecm_classifier_type_t type)$/;"	f	file:
ecm_front_end_ipv4_attrs	ecm_front_end_ipv4.c	/^static struct device_attribute *ecm_front_end_ipv4_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_front_end_ipv4_bridge_post_routing_hook	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_bridge_post_routing_hook(unsigned int hooknum,$/;"	f	file:
ecm_front_end_ipv4_connection_from_ct_get_and_ref	ecm_front_end_ipv4.c	/^static struct ecm_db_connection_instance *ecm_front_end_ipv4_connection_from_ct_get_and_ref(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_defunct_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_destroy_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_destroy_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_accel_ceased	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_accel_state_get	ecm_front_end_ipv4.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv4_connection_non_ported_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_accelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_action_seen	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_decelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_deref	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_non_ported_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_ref	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_non_ported_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_front_end_xml_state_get	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_non_ported_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv4_connection_non_ported_instance	ecm_front_end_ipv4.c	/^struct ecm_front_end_ipv4_connection_non_ported_instance {$/;"	s	file:
ecm_front_end_ipv4_connection_non_ported_instance_alloc	ecm_front_end_ipv4.c	/^static struct ecm_front_end_ipv4_connection_non_ported_instance *ecm_front_end_ipv4_connection_non_ported_instance_alloc($/;"	f	file:
ecm_front_end_ipv4_connection_regenerate	ecm_front_end_ipv4.c	/^static bool ecm_front_end_ipv4_connection_regenerate(struct ecm_db_connection_instance *ci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_defunct_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_destroy_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_destroy_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_accel_ceased	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_accel_state_get	ecm_front_end_ipv4.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv4_connection_tcp_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_accelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_action_seen	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_decelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_deref	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_tcp_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_ref	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_tcp_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_front_end_xml_state_get	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_tcp_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv4_connection_tcp_instance	ecm_front_end_ipv4.c	/^struct ecm_front_end_ipv4_connection_tcp_instance {$/;"	s	file:
ecm_front_end_ipv4_connection_tcp_instance_alloc	ecm_front_end_ipv4.c	/^static struct ecm_front_end_ipv4_connection_tcp_instance *ecm_front_end_ipv4_connection_tcp_instance_alloc($/;"	f	file:
ecm_front_end_ipv4_connection_udp_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_defunct_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_destroy_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_destroy_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_accel_ceased	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_accel_state_get	ecm_front_end_ipv4.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv4_connection_udp_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_accelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_action_seen	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_decelerate	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_deref	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_udp_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_ref	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_connection_udp_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_front_end_xml_state_get	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_connection_udp_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv4_connection_udp_instance	ecm_front_end_ipv4.c	/^struct ecm_front_end_ipv4_connection_udp_instance {$/;"	s	file:
ecm_front_end_ipv4_connection_udp_instance_alloc	ecm_front_end_ipv4.c	/^static struct ecm_front_end_ipv4_connection_udp_instance *ecm_front_end_ipv4_connection_udp_instance_alloc($/;"	f	file:
ecm_front_end_ipv4_conntrack_event	ecm_front_end_ipv4.c	/^EXPORT_SYMBOL(ecm_front_end_ipv4_conntrack_event);$/;"	v
ecm_front_end_ipv4_conntrack_event	ecm_front_end_ipv4.c	/^int ecm_front_end_ipv4_conntrack_event(unsigned long events, struct nf_conn *ct)$/;"	f
ecm_front_end_ipv4_conntrack_event_destroy	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_conntrack_event_destroy(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv4_conntrack_event_mark	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_conntrack_event_mark(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv4_dev	ecm_front_end_ipv4.c	/^static struct device ecm_front_end_ipv4_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_front_end_ipv4_dev_release	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_dev_release(struct device *dev)$/;"	f	file:
ecm_front_end_ipv4_driver_fail_limit_default	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_driver_fail_limit_default = 250;		\/* Default driver fail limit. *\/$/;"	v	file:
ecm_front_end_ipv4_exit	ecm_front_end_ipv4.c	/^EXPORT_SYMBOL(ecm_front_end_ipv4_exit);$/;"	v
ecm_front_end_ipv4_exit	ecm_front_end_ipv4.c	/^void ecm_front_end_ipv4_exit(void)$/;"	f
ecm_front_end_ipv4_get_accelerated_count	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_driver_fail_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_driver_fail_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_nack_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_nack_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_no_action_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_no_action_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_non_ported_accelerated_count	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_non_ported_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_stop	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_stop(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_tcp_accelerated_count	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_tcp_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_get_udp_accelerated_count	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_get_udp_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_host_establish_and_ref	ecm_front_end_ipv4.c	/^static struct ecm_db_host_instance *ecm_front_end_ipv4_host_establish_and_ref(ip_addr_t addr)$/;"	f	file:
ecm_front_end_ipv4_init	ecm_front_end_ipv4.c	/^EXPORT_SYMBOL(ecm_front_end_ipv4_init);$/;"	v
ecm_front_end_ipv4_init	ecm_front_end_ipv4.c	/^int ecm_front_end_ipv4_init(void)$/;"	f
ecm_front_end_ipv4_ip_process	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_ip_process(struct net_device *out_dev, struct net_device *in_dev,$/;"	f	file:
ecm_front_end_ipv4_lock	ecm_front_end_ipv4.c	/^static spinlock_t ecm_front_end_ipv4_lock;			\/* Protect against SMP access between netfilter, events and private threaded function. *\/$/;"	v	file:
ecm_front_end_ipv4_mapping_establish_and_ref	ecm_front_end_ipv4.c	/^static struct ecm_db_mapping_instance *ecm_front_end_ipv4_mapping_establish_and_ref(ip_addr_t addr, int port)$/;"	f	file:
ecm_front_end_ipv4_nack_limit_default	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_nack_limit_default = 250;			\/* Default nack limit. *\/$/;"	v	file:
ecm_front_end_ipv4_neigh_get	ecm_front_end_ipv4.c	/^static struct neighbour *ecm_front_end_ipv4_neigh_get(ip_addr_t addr)$/;"	f	file:
ecm_front_end_ipv4_net_dev_callback	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_net_dev_callback(void *app_data, struct nss_ipv4_msg *nim)$/;"	f	file:
ecm_front_end_ipv4_no_action_limit_default	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_no_action_limit_default = 250;		\/* Default no-action limit. *\/$/;"	v	file:
ecm_front_end_ipv4_node_establish_and_ref	ecm_front_end_ipv4.c	/^static struct ecm_db_node_instance *ecm_front_end_ipv4_node_establish_and_ref(struct net_device *dev, ip_addr_t addr,$/;"	f	file:
ecm_front_end_ipv4_non_ported_accelerated_count	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_non_ported_accelerated_count = 0;		\/* Number of Non-Ported connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv4_non_ported_process	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_non_ported_process(struct net_device *out_dev, struct net_device *out_dev_nat,$/;"	f	file:
ecm_front_end_ipv4_nss_ipv4_mgr	ecm_front_end_ipv4.c	/^static struct nss_ctx_instance *ecm_front_end_ipv4_nss_ipv4_mgr = NULL;$/;"	v	typeref:struct:nss_ctx_instance	file:
ecm_front_end_ipv4_post_routing_hook	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_post_routing_hook(unsigned int hooknum,$/;"	f	file:
ecm_front_end_ipv4_reclassify	ecm_front_end_ipv4.c	/^static bool ecm_front_end_ipv4_reclassify(struct ecm_db_connection_instance *ci, int assignment_count, struct ecm_classifier_instance *assignments[])$/;"	f	file:
ecm_front_end_ipv4_set_driver_fail_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_set_driver_fail_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_set_nack_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_set_nack_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_set_no_action_limit_default	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_set_no_action_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_set_stop	ecm_front_end_ipv4.c	/^static ssize_t ecm_front_end_ipv4_set_stop(struct device *dev,$/;"	f	file:
ecm_front_end_ipv4_sit_set_peer	ecm_front_end_ipv4.c	/^static void ecm_front_end_ipv4_sit_set_peer(struct ecm_front_end_ipv4_connection_non_ported_instance *fecnpi, struct sk_buff *skb)$/;"	f	file:
ecm_front_end_ipv4_stop	ecm_front_end_ipv4.c	/^EXPORT_SYMBOL(ecm_front_end_ipv4_stop);$/;"	v
ecm_front_end_ipv4_stop	ecm_front_end_ipv4.c	/^void ecm_front_end_ipv4_stop(int num)$/;"	f
ecm_front_end_ipv4_stopped	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_stopped = 0;			\/* When non-zero further traffic will not be processed *\/$/;"	v	file:
ecm_front_end_ipv4_subsys	ecm_front_end_ipv4.c	/^static struct bus_type ecm_front_end_ipv4_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_front_end_ipv4_tcp_accelerated_count	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_tcp_accelerated_count = 0;		\/* Number of TCP connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv4_tcp_process	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_tcp_process(struct net_device *out_dev, struct net_device *out_dev_nat,$/;"	f	file:
ecm_front_end_ipv4_terminate_pending	ecm_front_end_ipv4.c	/^static bool ecm_front_end_ipv4_terminate_pending = false;		\/* True when the user has signalled we should quit *\/$/;"	v	file:
ecm_front_end_ipv4_udp_accelerated_count	ecm_front_end_ipv4.c	/^static int ecm_front_end_ipv4_udp_accelerated_count = 0;		\/* Number of UDP connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv4_udp_process	ecm_front_end_ipv4.c	/^static unsigned int ecm_front_end_ipv4_udp_process(struct net_device *out_dev, struct net_device *out_dev_nat,$/;"	f	file:
ecm_front_end_ipv6_accelerated_count	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_accelerated_count = 0;			\/* Total offloads *\/$/;"	v	file:
ecm_front_end_ipv6_assign_classifier	ecm_front_end_ipv6.c	/^static struct ecm_classifier_instance *ecm_front_end_ipv6_assign_classifier(struct ecm_db_connection_instance *ci, ecm_classifier_type_t type)$/;"	f	file:
ecm_front_end_ipv6_attrs	ecm_front_end_ipv6.c	/^static struct device_attribute *ecm_front_end_ipv6_attrs[] = {$/;"	v	typeref:struct:device_attribute	file:
ecm_front_end_ipv6_bridge_post_routing_hook	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_bridge_post_routing_hook(unsigned int hooknum,$/;"	f	file:
ecm_front_end_ipv6_connection_from_ct_get_and_ref	ecm_front_end_ipv6.c	/^static struct ecm_db_connection_instance *ecm_front_end_ipv6_connection_from_ct_get_and_ref(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_defunct_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_destroy_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_destroy_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_accel_ceased	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_accel_state_get	ecm_front_end_ipv6.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv6_connection_non_ported_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_accelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_action_seen	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_decelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_deref	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_non_ported_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_ref	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_non_ported_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_front_end_xml_state_get	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_non_ported_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv6_connection_non_ported_instance	ecm_front_end_ipv6.c	/^struct ecm_front_end_ipv6_connection_non_ported_instance {$/;"	s	file:
ecm_front_end_ipv6_connection_non_ported_instance_alloc	ecm_front_end_ipv6.c	/^static struct ecm_front_end_ipv6_connection_non_ported_instance *ecm_front_end_ipv6_connection_non_ported_instance_alloc($/;"	f	file:
ecm_front_end_ipv6_connection_regenerate	ecm_front_end_ipv6.c	/^static bool ecm_front_end_ipv6_connection_regenerate(struct ecm_db_connection_instance *ci, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_defunct_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_destroy_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_destroy_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_accel_ceased	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_accel_state_get	ecm_front_end_ipv6.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv6_connection_tcp_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_accelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_action_seen	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_decelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_deref	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_tcp_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_ref	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_tcp_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_front_end_xml_state_get	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_tcp_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv6_connection_tcp_instance	ecm_front_end_ipv6.c	/^struct ecm_front_end_ipv6_connection_tcp_instance {$/;"	s	file:
ecm_front_end_ipv6_connection_tcp_instance_alloc	ecm_front_end_ipv6.c	/^static struct ecm_front_end_ipv6_connection_tcp_instance *ecm_front_end_ipv6_connection_tcp_instance_alloc($/;"	f	file:
ecm_front_end_ipv6_connection_udp_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_defunct_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_defunct_callback(void *arg)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_destroy_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_destroy_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_accel_ceased	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_front_end_accel_ceased(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_accel_state_get	ecm_front_end_ipv6.c	/^static ecm_front_end_acceleration_mode_t ecm_front_end_ipv6_connection_udp_front_end_accel_state_get(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_accelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_front_end_accelerate(struct ecm_front_end_connection_instance *feci,$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_action_seen	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_front_end_action_seen(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_decelerate	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_front_end_decelerate(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_deref	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_udp_front_end_deref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_ref	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_connection_udp_front_end_ref(struct ecm_front_end_connection_instance *feci)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_front_end_xml_state_get	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_connection_udp_front_end_xml_state_get(struct ecm_front_end_connection_instance *feci, char *buf, int buf_sz)$/;"	f	file:
ecm_front_end_ipv6_connection_udp_instance	ecm_front_end_ipv6.c	/^struct ecm_front_end_ipv6_connection_udp_instance {$/;"	s	file:
ecm_front_end_ipv6_connection_udp_instance_alloc	ecm_front_end_ipv6.c	/^static struct ecm_front_end_ipv6_connection_udp_instance *ecm_front_end_ipv6_connection_udp_instance_alloc($/;"	f	file:
ecm_front_end_ipv6_conntrack_event	ecm_front_end_ipv6.c	/^EXPORT_SYMBOL(ecm_front_end_ipv6_conntrack_event);$/;"	v
ecm_front_end_ipv6_conntrack_event	ecm_front_end_ipv6.c	/^int ecm_front_end_ipv6_conntrack_event(unsigned long events, struct nf_conn *ct)$/;"	f
ecm_front_end_ipv6_conntrack_event_destroy	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_conntrack_event_destroy(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv6_conntrack_event_mark	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_conntrack_event_mark(struct nf_conn *ct)$/;"	f	file:
ecm_front_end_ipv6_dev	ecm_front_end_ipv6.c	/^static struct device ecm_front_end_ipv6_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_front_end_ipv6_dev_release	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_dev_release(struct device *dev)$/;"	f	file:
ecm_front_end_ipv6_driver_fail_limit_default	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_driver_fail_limit_default = 250;		\/* Default driver fail limit. *\/$/;"	v	file:
ecm_front_end_ipv6_exit	ecm_front_end_ipv6.c	/^EXPORT_SYMBOL(ecm_front_end_ipv6_exit);$/;"	v
ecm_front_end_ipv6_exit	ecm_front_end_ipv6.c	/^void ecm_front_end_ipv6_exit(void)$/;"	f
ecm_front_end_ipv6_get_accelerated_count	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_driver_fail_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_driver_fail_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_nack_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_nack_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_no_action_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_no_action_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_non_ported_accelerated_count	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_non_ported_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_stop	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_stop(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_tcp_accelerated_count	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_tcp_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_get_udp_accelerated_count	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_get_udp_accelerated_count(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_host_establish_and_ref	ecm_front_end_ipv6.c	/^static struct ecm_db_host_instance *ecm_front_end_ipv6_host_establish_and_ref(ip_addr_t addr)$/;"	f	file:
ecm_front_end_ipv6_init	ecm_front_end_ipv6.c	/^EXPORT_SYMBOL(ecm_front_end_ipv6_init);$/;"	v
ecm_front_end_ipv6_init	ecm_front_end_ipv6.c	/^int ecm_front_end_ipv6_init(void)$/;"	f
ecm_front_end_ipv6_interface_heirarchy_construct	ecm_front_end_ipv6.c	/^int32_t ecm_front_end_ipv6_interface_heirarchy_construct(struct ecm_db_iface_instance *interfaces[], ip_addr_t packet_src_addr, ip_addr_t packet_dest_addr, int packet_protocol,$/;"	f
ecm_front_end_ipv6_ip_process	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_ip_process(struct net_device *out_dev, struct net_device *in_dev,$/;"	f	file:
ecm_front_end_ipv6_ipv6_neigh_get	ecm_front_end_ipv6.c	/^static struct neighbour *ecm_front_end_ipv6_ipv6_neigh_get(ip_addr_t addr)$/;"	f	file:
ecm_front_end_ipv6_lock	ecm_front_end_ipv6.c	/^static spinlock_t ecm_front_end_ipv6_lock;			\/* Protect against SMP access between netfilter, events and private threaded function. *\/$/;"	v	file:
ecm_front_end_ipv6_mapping_establish_and_ref	ecm_front_end_ipv6.c	/^static struct ecm_db_mapping_instance *ecm_front_end_ipv6_mapping_establish_and_ref(ip_addr_t addr, int port)$/;"	f	file:
ecm_front_end_ipv6_nack_limit_default	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_nack_limit_default = 250;			\/* Default nack limit. *\/$/;"	v	file:
ecm_front_end_ipv6_net_dev_callback	ecm_front_end_ipv6.c	/^static void ecm_front_end_ipv6_net_dev_callback(void *app_data, struct nss_ipv6_msg *nim)$/;"	f	file:
ecm_front_end_ipv6_no_action_limit_default	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_no_action_limit_default = 250;		\/* Default no-action limit. *\/$/;"	v	file:
ecm_front_end_ipv6_node_establish_and_ref	ecm_front_end_ipv6.c	/^static struct ecm_db_node_instance *ecm_front_end_ipv6_node_establish_and_ref(struct net_device *dev, ip_addr_t addr,$/;"	f	file:
ecm_front_end_ipv6_non_ported_accelerated_count	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_non_ported_accelerated_count = 0;		\/* Number of Non-Ported connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv6_non_ported_process	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_non_ported_process(struct net_device *out_dev,$/;"	f	file:
ecm_front_end_ipv6_nss_ipv6_mgr	ecm_front_end_ipv6.c	/^static struct nss_ctx_instance *ecm_front_end_ipv6_nss_ipv6_mgr = NULL;$/;"	v	typeref:struct:nss_ctx_instance	file:
ecm_front_end_ipv6_post_routing_hook	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_post_routing_hook(unsigned int hooknum,$/;"	f	file:
ecm_front_end_ipv6_reclassify	ecm_front_end_ipv6.c	/^static bool ecm_front_end_ipv6_reclassify(struct ecm_db_connection_instance *ci, int assignment_count, struct ecm_classifier_instance *assignments[])$/;"	f	file:
ecm_front_end_ipv6_send_neighbour_solicitation	ecm_front_end_ipv6.c	/^void ecm_front_end_ipv6_send_neighbour_solicitation(struct net_device *dev, ip_addr_t addr)$/;"	f
ecm_front_end_ipv6_set_driver_fail_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_set_driver_fail_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_set_nack_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_set_nack_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_set_no_action_limit_default	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_set_no_action_limit_default(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_set_stop	ecm_front_end_ipv6.c	/^static ssize_t ecm_front_end_ipv6_set_stop(struct device *dev,$/;"	f	file:
ecm_front_end_ipv6_stop	ecm_front_end_ipv6.c	/^EXPORT_SYMBOL(ecm_front_end_ipv6_stop);$/;"	v
ecm_front_end_ipv6_stop	ecm_front_end_ipv6.c	/^void ecm_front_end_ipv6_stop(int num)$/;"	f
ecm_front_end_ipv6_stopped	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_stopped = 0;			\/* When non-zero further traffic will not be processed *\/$/;"	v	file:
ecm_front_end_ipv6_subsys	ecm_front_end_ipv6.c	/^static struct bus_type ecm_front_end_ipv6_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_front_end_ipv6_tcp_accelerated_count	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_tcp_accelerated_count = 0;		\/* Number of TCP connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv6_tcp_process	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_tcp_process(struct net_device *out_dev,$/;"	f	file:
ecm_front_end_ipv6_terminate_pending	ecm_front_end_ipv6.c	/^static bool ecm_front_end_ipv6_terminate_pending = false;		\/* True when the user has signalled we should quit *\/$/;"	v	file:
ecm_front_end_ipv6_udp_accelerated_count	ecm_front_end_ipv6.c	/^static int ecm_front_end_ipv6_udp_accelerated_count = 0;		\/* Number of UDP connections currently offloaded *\/$/;"	v	file:
ecm_front_end_ipv6_udp_process	ecm_front_end_ipv6.c	/^static unsigned int ecm_front_end_ipv6_udp_process(struct net_device *out_dev,$/;"	f	file:
ecm_front_end_is_bridge_device	ecm_front_end_types.h	21;"	d
ecm_front_end_is_bridge_port	ecm_front_end_types.h	20;"	d
ecm_front_end_is_lag_master	ecm_front_end_types.h	26;"	d
ecm_front_end_is_lag_slave	ecm_front_end_types.h	28;"	d
ecm_init	ecm_init.c	/^static int __init ecm_init(void)$/;"	f	file:
ecm_interface_bridge_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_bridge_interface_establish(struct ecm_db_interface_info_bridge *type_info,$/;"	f	file:
ecm_interface_dev	ecm_interface.c	/^static struct device ecm_interface_dev;		\/* System device linkage *\/$/;"	v	typeref:struct:device	file:
ecm_interface_dev_find_by_addr	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_dev_find_by_addr);$/;"	v
ecm_interface_dev_find_by_addr	ecm_interface.c	/^struct net_device *ecm_interface_dev_find_by_addr(ip_addr_t addr, bool *from_local_addr)$/;"	f
ecm_interface_dev_find_by_local_addr	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_dev_find_by_local_addr);$/;"	v
ecm_interface_dev_find_by_local_addr	ecm_interface.c	/^struct net_device *ecm_interface_dev_find_by_local_addr(ip_addr_t addr)$/;"	f
ecm_interface_dev_find_by_local_addr_ipv4	ecm_interface.c	/^static struct net_device *ecm_interface_dev_find_by_local_addr_ipv4(ip_addr_t addr)$/;"	f	file:
ecm_interface_dev_find_by_local_addr_ipv6	ecm_interface.c	/^static struct net_device *ecm_interface_dev_find_by_local_addr_ipv6(ip_addr_t addr)$/;"	f	file:
ecm_interface_dev_regenerate_connections	ecm_interface.c	/^void ecm_interface_dev_regenerate_connections(struct net_device *dev)$/;"	f
ecm_interface_dev_release	ecm_interface.c	/^static void ecm_interface_dev_release(struct device *dev)$/;"	f	file:
ecm_interface_establish_and_ref	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_establish_and_ref);$/;"	v
ecm_interface_establish_and_ref	ecm_interface.c	/^struct ecm_db_iface_instance *ecm_interface_establish_and_ref(struct net_device *dev)$/;"	f
ecm_interface_ethernet_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_ethernet_interface_establish(struct ecm_db_interface_info_ethernet *type_info,$/;"	f	file:
ecm_interface_exit	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_exit);$/;"	v
ecm_interface_exit	ecm_interface.c	/^void ecm_interface_exit(void)$/;"	f
ecm_interface_find_route_by_addr	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_find_route_by_addr);$/;"	v
ecm_interface_find_route_by_addr	ecm_interface.c	/^bool ecm_interface_find_route_by_addr(ip_addr_t addr, struct ecm_interface_route *ecm_rt)$/;"	f
ecm_interface_find_route_by_addr_ipv4	ecm_interface.c	/^static bool ecm_interface_find_route_by_addr_ipv4(ip_addr_t addr, struct ecm_interface_route *ecm_rt)$/;"	f	file:
ecm_interface_find_route_by_addr_ipv6	ecm_interface.c	/^static bool ecm_interface_find_route_by_addr_ipv6(ip_addr_t addr, struct ecm_interface_route *ecm_rt)$/;"	f	file:
ecm_interface_get_and_hold_dev_master	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_get_and_hold_dev_master);$/;"	v
ecm_interface_get_and_hold_dev_master	ecm_interface.c	/^struct net_device *ecm_interface_get_and_hold_dev_master(struct net_device *dev)$/;"	f
ecm_interface_get_stop	ecm_interface.c	/^static ssize_t ecm_interface_get_stop(struct device *dev,$/;"	f	file:
ecm_interface_heirarchy_construct	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_heirarchy_construct);$/;"	v
ecm_interface_heirarchy_construct	ecm_interface.c	/^int32_t ecm_interface_heirarchy_construct(struct ecm_db_iface_instance *interfaces[], ip_addr_t packet_src_addr, ip_addr_t packet_dest_addr, int packet_protocol,$/;"	f
ecm_interface_init	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_init);$/;"	v
ecm_interface_init	ecm_interface.c	/^int ecm_interface_init(void)$/;"	f
ecm_interface_ipsec_tunnel_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_ipsec_tunnel_interface_establish(struct ecm_db_interface_info_ipsec_tunnel *type_info,$/;"	f	file:
ecm_interface_lag_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_lag_interface_establish(struct ecm_db_interface_info_lag *type_info,$/;"	f	file:
ecm_interface_list_stats_update	ecm_interface.c	/^static void ecm_interface_list_stats_update(int iface_list_first, struct ecm_db_iface_instance *iface_list[], uint8_t *mac_addr,$/;"	f	file:
ecm_interface_lock	ecm_interface.c	/^static spinlock_t ecm_interface_lock;			\/* Protect against SMP access between netfilter, events and private threaded function. *\/$/;"	v	file:
ecm_interface_loopback_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_loopback_interface_establish(struct ecm_db_interface_info_loopback *type_info,$/;"	f	file:
ecm_interface_mac_addr_get	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_mac_addr_get);$/;"	v
ecm_interface_mac_addr_get	ecm_interface.c	/^bool ecm_interface_mac_addr_get(ip_addr_t addr, uint8_t *mac_addr, bool *on_link, ip_addr_t gw_addr)$/;"	f
ecm_interface_mac_addr_get_ipv4	ecm_interface.c	/^static bool ecm_interface_mac_addr_get_ipv4(ip_addr_t addr, uint8_t *mac_addr, bool *on_link, ip_addr_t gw_addr)$/;"	f	file:
ecm_interface_mac_addr_get_ipv6	ecm_interface.c	/^static bool ecm_interface_mac_addr_get_ipv6(ip_addr_t addr, uint8_t *mac_addr, bool *on_link, ip_addr_t gw_addr)$/;"	f	file:
ecm_interface_mtu_change	ecm_interface.c	/^static void ecm_interface_mtu_change(struct net_device *dev)$/;"	f	file:
ecm_interface_netdev_notifier_callback	ecm_interface.c	/^static int ecm_interface_netdev_notifier_callback(struct notifier_block *this, unsigned long event, void *ptr)$/;"	f	file:
ecm_interface_pppoe_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_pppoe_interface_establish(struct ecm_db_interface_info_pppoe *type_info,$/;"	f	file:
ecm_interface_regenerate_connection	ecm_interface.c	/^void ecm_interface_regenerate_connection(struct ecm_db_connection_instance *ci)$/;"	f
ecm_interface_regenerate_connections	ecm_interface.c	/^static void ecm_interface_regenerate_connections(struct ecm_db_iface_instance *ii)$/;"	f	file:
ecm_interface_route	ecm_interface.h	/^struct ecm_interface_route {$/;"	s
ecm_interface_route_release	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_route_release);$/;"	v
ecm_interface_route_release	ecm_interface.c	/^void ecm_interface_route_release(struct ecm_interface_route *rt)$/;"	f
ecm_interface_set_stop	ecm_interface.c	/^static ssize_t ecm_interface_set_stop(struct device *dev,$/;"	f	file:
ecm_interface_sit_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_sit_interface_establish(struct ecm_db_interface_info_sit *type_info,$/;"	f	file:
ecm_interface_skip_l2tp_pptp	ecm_interface.c	/^bool ecm_interface_skip_l2tp_pptp(struct sk_buff *skb, const struct net_device *out)$/;"	f
ecm_interface_stats_update	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_stats_update);$/;"	v
ecm_interface_stats_update	ecm_interface.c	/^void ecm_interface_stats_update(struct ecm_db_connection_instance *ci,$/;"	f
ecm_interface_stop	ecm_interface.c	/^EXPORT_SYMBOL(ecm_interface_stop);$/;"	v
ecm_interface_stop	ecm_interface.c	/^void ecm_interface_stop(int num)$/;"	f
ecm_interface_stopped	ecm_interface.c	/^static int ecm_interface_stopped = 0;			\/* When non-zero further traffic will not be processed *\/$/;"	v	file:
ecm_interface_subsys	ecm_interface.c	/^static struct bus_type ecm_interface_subsys = {$/;"	v	typeref:struct:bus_type	file:
ecm_interface_terminate_pending	ecm_interface.c	/^static bool ecm_interface_terminate_pending = false;		\/* True when the user has signalled we should quit *\/$/;"	v	file:
ecm_interface_tunipip6_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_tunipip6_interface_establish(struct ecm_db_interface_info_tunipip6 *type_info,$/;"	f	file:
ecm_interface_unknown_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_unknown_interface_establish(struct ecm_db_interface_info_unknown *type_info,$/;"	f	file:
ecm_interface_vlan_interface_establish	ecm_interface.c	/^static struct ecm_db_iface_instance *ecm_interface_vlan_interface_establish(struct ecm_db_interface_info_vlan *type_info,$/;"	f	file:
ecm_ip_addr_in_range	ecm_types.h	/^static inline bool ecm_ip_addr_in_range(ip_addr_t a, ip_addr_t s, ip_addr_t e)$/;"	f
ecm_ip_addr_is_non_unicast	ecm_types.h	/^static inline bool ecm_ip_addr_is_non_unicast(ip_addr_t addr)$/;"	f
ecm_ip_addr_to_string	ecm_types.h	/^static inline void ecm_ip_addr_to_string(char *str, ip_addr_t a)$/;"	f
ecm_ip_protocol	ecm_tracker.c	/^	ecm_tracker_ip_protocol_type_t ecm_ip_protocol;		\/* The ECM Tracker protocol identifier equivalent *\/$/;"	m	struct:ecm_tracker_ip_protocols	file:
ecm_mac_addr_equal	ecm_types.h	/^static inline unsigned ecm_mac_addr_equal(const u8 *addr1, const u8 *addr2)$/;"	f
ecm_nss_type_check_ecm_ip_addr	ecm_types.h	/^static inline void ecm_nss_type_check_ecm_ip_addr(ip_addr_t ipaddr){}$/;"	f
ecm_nss_type_check_linux_ipv4	ecm_types.h	/^static inline void ecm_nss_type_check_linux_ipv4(__be32 ipaddr){}$/;"	f
ecm_nss_type_check_linux_ipv6	ecm_types.h	/^static inline void ecm_nss_type_check_linux_ipv6(struct in6_addr in6){}$/;"	f
ecm_nss_type_check_nss_ipv4	ecm_types.h	/^static inline void ecm_nss_type_check_nss_ipv4(uint32_t addr){}$/;"	f
ecm_nss_type_check_nss_ipv6	ecm_types.h	/^static inline void ecm_nss_type_check_nss_ipv6(uint32_t ip6[4]){}$/;"	f
ecm_string_to_ip_addr	ecm_types.h	/^static inline bool ecm_string_to_ip_addr(ip_addr_t addr, char *ip_str)$/;"	f
ecm_tracker_connection_state_strings	ecm_tracker.c	/^static char *ecm_tracker_connection_state_strings[] = {$/;"	v	file:
ecm_tracker_connection_state_t	ecm_tracker.h	/^typedef enum ecm_tracker_connection_states ecm_tracker_connection_state_t;$/;"	t	typeref:enum:ecm_tracker_connection_states
ecm_tracker_connection_state_to_string	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_connection_state_to_string);$/;"	v
ecm_tracker_connection_state_to_string	ecm_tracker.c	/^ecm_tracker_connection_state_to_string(enum ecm_tracker_connection_states s)$/;"	f
ecm_tracker_connection_states	ecm_tracker.h	/^enum ecm_tracker_connection_states {$/;"	g
ecm_tracker_data_buffer_limit	ecm_tracker.c	/^int ecm_tracker_data_buffer_limit = ECM_TRACKER_GLOBAL_DATA_BUFFER_LIMIT_DEFAULT;$/;"	v
ecm_tracker_data_buffer_total	ecm_tracker.c	/^int ecm_tracker_data_buffer_total = 0;			\/* Data buffer total allocated for all skb list instances *\/$/;"	v
ecm_tracker_data_buffer_total_get	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_buffer_total_get);$/;"	v
ecm_tracker_data_buffer_total_get	ecm_tracker.c	/^uint32_t ecm_tracker_data_buffer_total_get(void)$/;"	f
ecm_tracker_data_limit	ecm_tracker.c	/^int ecm_tracker_data_limit = ECM_TRACKER_GLOBAL_DATA_LIMIT_DEFAULT;$/;"	v
ecm_tracker_data_limit_get	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_limit_get);$/;"	v
ecm_tracker_data_limit_get	ecm_tracker.c	/^uint32_t ecm_tracker_data_limit_get(void)$/;"	f
ecm_tracker_data_limit_get_method_t	ecm_tracker.h	/^typedef int32_t (*ecm_tracker_data_limit_get_method_t)(struct ecm_tracker_instance *ti);$/;"	t
ecm_tracker_data_limit_set	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_limit_set);$/;"	v
ecm_tracker_data_limit_set	ecm_tracker.c	/^void ecm_tracker_data_limit_set(uint32_t limit)$/;"	f
ecm_tracker_data_limit_set_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_data_limit_set_method_t)(struct ecm_tracker_instance *ti, int32_t data_limit);$/;"	t
ecm_tracker_data_total	ecm_tracker.c	/^int ecm_tracker_data_total = 0;				\/* Data total for all skb list instances *\/$/;"	v
ecm_tracker_data_total_decrease	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_total_decrease);$/;"	v
ecm_tracker_data_total_decrease	ecm_tracker.c	/^void ecm_tracker_data_total_decrease(uint32_t n, uint32_t data_buffer_size)$/;"	f
ecm_tracker_data_total_get	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_total_get);$/;"	v
ecm_tracker_data_total_get	ecm_tracker.c	/^uint32_t ecm_tracker_data_total_get(void)$/;"	f
ecm_tracker_data_total_get_method_t	ecm_tracker.h	/^typedef int32_t (*ecm_tracker_data_total_get_method_t)(struct ecm_tracker_instance *ti);$/;"	t
ecm_tracker_data_total_increase	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_data_total_increase);$/;"	v
ecm_tracker_data_total_increase	ecm_tracker.c	/^bool ecm_tracker_data_total_increase(uint32_t n, uint32_t data_buffer_size)$/;"	f
ecm_tracker_datagram_add_method_t	ecm_tracker.h	/^typedef bool (*ecm_tracker_datagram_add_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct sk_buff *skb);$/;"	t
ecm_tracker_datagram_alloc	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_alloc);$/;"	v
ecm_tracker_datagram_alloc	ecm_tracker_datagram.c	/^struct ecm_tracker_datagram_instance *ecm_tracker_datagram_alloc(void)$/;"	f
ecm_tracker_datagram_connection_state_matrix	ecm_tracker_datagram.c	/^static ecm_tracker_connection_state_t ecm_tracker_datagram_connection_state_matrix[ECM_TRACKER_SENDER_STATE_MAX][ECM_TRACKER_SENDER_STATE_MAX] =$/;"	v	file:
ecm_tracker_datagram_count	ecm_tracker_datagram.c	/^int ecm_tracker_datagram_count = 0;		\/* Counts the number of DATAGRAM data trackers right now *\/$/;"	v
ecm_tracker_datagram_count_get_method_t	ecm_tracker.h	/^typedef int32_t (*ecm_tracker_datagram_count_get_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender);$/;"	t
ecm_tracker_datagram_data_limit_get_callback	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_data_limit_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_datagram_data_limit_set_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_data_limit_set_callback(struct ecm_tracker_instance *ti, int32_t data_limit)$/;"	f	file:
ecm_tracker_datagram_data_total_get_callback	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_data_total_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_datagram_datagram_add	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_datagram_add);$/;"	v
ecm_tracker_datagram_datagram_add	ecm_tracker_datagram.c	/^static bool ecm_tracker_datagram_datagram_add(struct ecm_tracker_datagram_instance *uti, ecm_tracker_sender_type_t sender, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_datagram_datagram_add_callback	ecm_tracker_datagram.c	/^static bool ecm_tracker_datagram_datagram_add_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_datagram_datagram_count_get	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_datagram_count_get(struct ecm_tracker_datagram_internal_instance *dtii, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_datagram_datagram_count_get_callback	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_datagram_count_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_datagram_datagram_discard	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_datagram_discard(struct ecm_tracker_datagram_internal_instance *dtii, ecm_tracker_sender_type_t sender, int32_t n)$/;"	f	file:
ecm_tracker_datagram_datagram_discard_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_datagram_discard_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t n)$/;"	f	file:
ecm_tracker_datagram_datagram_read	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_datagram_read);$/;"	v
ecm_tracker_datagram_datagram_read	ecm_tracker_datagram.c	/^static int ecm_tracker_datagram_datagram_read(struct ecm_tracker_datagram_instance *uti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer)$/;"	f	file:
ecm_tracker_datagram_datagram_read_callback	ecm_tracker_datagram.c	/^static int ecm_tracker_datagram_datagram_read_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer)$/;"	f	file:
ecm_tracker_datagram_datagram_size_get	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_datagram_size_get);$/;"	v
ecm_tracker_datagram_datagram_size_get	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_datagram_size_get(struct ecm_tracker_datagram_instance *uti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f	file:
ecm_tracker_datagram_datagram_size_get_callback	ecm_tracker_datagram.c	/^static int32_t ecm_tracker_datagram_datagram_size_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f	file:
ecm_tracker_datagram_deref	ecm_tracker_datagram.c	/^static int ecm_tracker_datagram_deref(struct ecm_tracker_datagram_internal_instance *dtii)$/;"	f	file:
ecm_tracker_datagram_deref_callback	ecm_tracker_datagram.c	/^static int ecm_tracker_datagram_deref_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_datagram_discard_all	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_discard_all);$/;"	v
ecm_tracker_datagram_discard_all	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_discard_all(struct ecm_tracker_datagram_internal_instance *dtii)$/;"	f	file:
ecm_tracker_datagram_discard_all_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_discard_all_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_datagram_discard_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_datagram_discard_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t n);$/;"	t
ecm_tracker_datagram_init	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_init);$/;"	v
ecm_tracker_datagram_init	ecm_tracker_datagram.c	/^void ecm_tracker_datagram_init(struct ecm_tracker_datagram_instance *uti, int32_t data_limit)$/;"	f
ecm_tracker_datagram_instance	ecm_tracker_datagram.h	/^struct ecm_tracker_datagram_instance {$/;"	s
ecm_tracker_datagram_internal_instance	ecm_tracker_datagram.c	/^struct ecm_tracker_datagram_internal_instance {$/;"	s	file:
ecm_tracker_datagram_lock	ecm_tracker_datagram.c	/^spinlock_t ecm_tracker_datagram_lock;		\/* Global lock for the tracker globals *\/$/;"	v
ecm_tracker_datagram_module_exit	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_module_exit);$/;"	v
ecm_tracker_datagram_module_exit	ecm_tracker_datagram.c	/^void ecm_tracker_datagram_module_exit(void)$/;"	f
ecm_tracker_datagram_module_init	ecm_tracker_datagram.c	/^EXPORT_SYMBOL(ecm_tracker_datagram_module_init);$/;"	v
ecm_tracker_datagram_module_init	ecm_tracker_datagram.c	/^int ecm_tracker_datagram_module_init(void)$/;"	f
ecm_tracker_datagram_read_method_t	ecm_tracker.h	/^typedef int (*ecm_tracker_datagram_read_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer);$/;"	t
ecm_tracker_datagram_ref	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_ref(struct ecm_tracker_datagram_internal_instance *dtii)$/;"	f	file:
ecm_tracker_datagram_ref_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_ref_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_datagram_size_get_method_t	ecm_tracker.h	/^typedef int32_t (*ecm_tracker_datagram_size_get_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i);$/;"	t
ecm_tracker_datagram_state_get_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_state_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_state_t *src_state,$/;"	f	file:
ecm_tracker_datagram_state_update_callback	ecm_tracker_datagram.c	/^static void ecm_tracker_datagram_state_update_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_datagram_xml_state_get_callback	ecm_tracker_datagram.c	/^static int ecm_tracker_datagram_xml_state_get_callback(struct ecm_tracker_instance *ti, char *buf, int buf_sz)$/;"	f	file:
ecm_tracker_deref_method_t	ecm_tracker.h	/^typedef int (*ecm_tracker_deref_method_t)(struct ecm_tracker_instance *ti);$/;"	t
ecm_tracker_discard_all_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_discard_all_method_t)(struct ecm_tracker_instance *ti);$/;"	t
ecm_tracker_exit	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_exit);$/;"	v
ecm_tracker_exit	ecm_tracker.c	/^void ecm_tracker_exit(void)$/;"	f
ecm_tracker_init	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_init);$/;"	v
ecm_tracker_init	ecm_tracker.c	/^int ecm_tracker_init(void)$/;"	f
ecm_tracker_instance	ecm_tracker.h	/^struct ecm_tracker_instance {$/;"	s
ecm_tracker_ip_check_header_and_read	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_ip_check_header_and_read);$/;"	v
ecm_tracker_ip_check_header_and_read	ecm_tracker.c	/^bool ecm_tracker_ip_check_header_and_read(struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb)$/;"	f
ecm_tracker_ip_header	ecm_tracker.h	/^struct ecm_tracker_ip_header {$/;"	s
ecm_tracker_ip_header_helper_ah	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_ah(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_gre	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_gre(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_icmp	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_icmp(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_ipv6_fragment	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_ipv6_fragment(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_ipv6_generic	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_ipv6_generic(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_ipv6_icmp	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_ipv6_icmp(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_method_t	ecm_tracker.c	/^typedef bool (*ecm_tracker_ip_header_helper_method_t)(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb, uint8_t protocol, ecm_tracker_ip_protocol_type_t ecm_ip_protocol, uint32_t offset, uint32_t remain, int16_t *next_hdr);$/;"	t	file:
ecm_tracker_ip_header_helper_tcp	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_tcp(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_udp	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_udp(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_header_helper_unknown	ecm_tracker.c	/^static bool ecm_tracker_ip_header_helper_unknown(struct ecm_tracker_ip_protocols *etip, struct ecm_tracker_ip_protocol_header *etiph, struct ecm_tracker_ip_header *ip_hdr,$/;"	f	file:
ecm_tracker_ip_protocol_header	ecm_tracker.h	/^struct ecm_tracker_ip_protocol_header {$/;"	s
ecm_tracker_ip_protocol_type_t	ecm_tracker.h	/^typedef enum ecm_tracker_ip_protocol_types ecm_tracker_ip_protocol_type_t;$/;"	t	typeref:enum:ecm_tracker_ip_protocol_types
ecm_tracker_ip_protocol_types	ecm_tracker.h	/^enum ecm_tracker_ip_protocol_types {$/;"	g
ecm_tracker_ip_protocols	ecm_tracker.c	/^static struct ecm_tracker_ip_protocols {$/;"	s	file:
ecm_tracker_ip_protocols_known	ecm_tracker.c	/^} ecm_tracker_ip_protocols_known[256] =$/;"	v	typeref:struct:ecm_tracker_ip_protocols	file:
ecm_tracker_lock	ecm_tracker.c	/^spinlock_t ecm_tracker_lock;				\/* Global lock for the tracker globals *\/$/;"	v
ecm_tracker_module_get	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_module_get);$/;"	v
ecm_tracker_module_get	ecm_tracker.c	/^void ecm_tracker_module_get(void)$/;"	f
ecm_tracker_module_put	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_module_put);$/;"	v
ecm_tracker_module_put	ecm_tracker.c	/^void ecm_tracker_module_put(void)$/;"	f
ecm_tracker_ref_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_ref_method_t)(struct ecm_tracker_instance *ti);$/;"	t
ecm_tracker_sender_state_strings	ecm_tracker.c	/^static char *ecm_tracker_sender_state_strings[] = {$/;"	v	file:
ecm_tracker_sender_state_t	ecm_tracker.h	/^typedef enum ecm_tracker_sender_states ecm_tracker_sender_state_t;$/;"	t	typeref:enum:ecm_tracker_sender_states
ecm_tracker_sender_state_to_string	ecm_tracker.c	/^EXPORT_SYMBOL(ecm_tracker_sender_state_to_string);$/;"	v
ecm_tracker_sender_state_to_string	ecm_tracker.c	/^ecm_tracker_sender_state_to_string(enum ecm_tracker_sender_states s)$/;"	f
ecm_tracker_sender_states	ecm_tracker.h	/^enum ecm_tracker_sender_states {$/;"	g
ecm_tracker_sender_type_t	ecm_tracker.h	/^typedef enum ecm_tracker_sender_types ecm_tracker_sender_type_t;$/;"	t	typeref:enum:ecm_tracker_sender_types
ecm_tracker_sender_types	ecm_tracker.h	/^enum ecm_tracker_sender_types {$/;"	g
ecm_tracker_state_get_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_state_get_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_state_t *src_state, ecm_tracker_sender_state_t *dest_state, ecm_tracker_connection_state_t *state, ecm_db_timer_group_t *tg);$/;"	t
ecm_tracker_state_update_method_t	ecm_tracker.h	/^typedef void (*ecm_tracker_state_update_method_t)(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb);$/;"	t
ecm_tracker_tcp_alloc	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_alloc);$/;"	v
ecm_tracker_tcp_alloc	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_instance *ecm_tracker_tcp_alloc(void)$/;"	f
ecm_tracker_tcp_bytes_avail_get_callback	ecm_tracker_tcp.c	/^static uint32_t ecm_tracker_tcp_bytes_avail_get_callback(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_tcp_bytes_avail_get_method_t	ecm_tracker_tcp.h	/^typedef uint32_t (*ecm_tracker_tcp_bytes_avail_get_method_t)(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender);$/;"	t
ecm_tracker_tcp_bytes_discard	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_bytes_discard(struct ecm_tracker_tcp_internal_instance *ttii, struct ecm_tracker_tcp_host_data *data, uint32_t n)$/;"	f	file:
ecm_tracker_tcp_bytes_discard_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_bytes_discard_callback(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint32_t n)$/;"	f	file:
ecm_tracker_tcp_bytes_discard_method_t	ecm_tracker_tcp.h	/^typedef void (*ecm_tracker_tcp_bytes_discard_method_t)(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint32_t n);$/;"	t
ecm_tracker_tcp_bytes_read_callback	ecm_tracker_tcp.c	/^static int ecm_tracker_tcp_bytes_read_callback(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint32_t offset, uint32_t size, void *buffer)$/;"	f	file:
ecm_tracker_tcp_bytes_read_method_t	ecm_tracker_tcp.h	/^typedef int (*ecm_tracker_tcp_bytes_read_method_t)(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint32_t offset, uint32_t size, void *buffer);$/;"	t
ecm_tracker_tcp_check_header_and_read	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_check_header_and_read);$/;"	v
ecm_tracker_tcp_check_header_and_read	ecm_tracker_tcp.c	/^struct tcphdr *ecm_tracker_tcp_check_header_and_read(struct sk_buff *skb, struct ecm_tracker_ip_header *ip_hdr, struct tcphdr *port_buffer)$/;"	f
ecm_tracker_tcp_connection_state_matrix	ecm_tracker_tcp.c	/^static ecm_tracker_connection_state_t ecm_tracker_tcp_connection_state_matrix[ECM_TRACKER_SENDER_STATE_MAX][ECM_TRACKER_SENDER_STATE_MAX] =$/;"	v	file:
ecm_tracker_tcp_count	ecm_tracker_tcp.c	/^int ecm_tracker_tcp_count = 0;		\/* Counts the number of TCP data trackers right now *\/$/;"	v
ecm_tracker_tcp_data_limit_get_callback	ecm_tracker_tcp.c	/^static int32_t ecm_tracker_tcp_data_limit_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_tcp_data_limit_set_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_data_limit_set_callback(struct ecm_tracker_instance *ti, int32_t data_limit)$/;"	f	file:
ecm_tracker_tcp_data_total_get_callback	ecm_tracker_tcp.c	/^static int32_t ecm_tracker_tcp_data_total_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_tcp_datagram_add_callback	ecm_tracker_tcp.c	/^static bool ecm_tracker_tcp_datagram_add_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_tcp_datagram_count_get_callback	ecm_tracker_tcp.c	/^static int32_t ecm_tracker_tcp_datagram_count_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_tcp_datagram_discard_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_datagram_discard_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t n)$/;"	f	file:
ecm_tracker_tcp_datagram_read_callback	ecm_tracker_tcp.c	/^static int ecm_tracker_tcp_datagram_read_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer)$/;"	f	file:
ecm_tracker_tcp_datagram_size_get_callback	ecm_tracker_tcp.c	/^static int32_t ecm_tracker_tcp_datagram_size_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f	file:
ecm_tracker_tcp_deref_callback	ecm_tracker_tcp.c	/^int ecm_tracker_tcp_deref_callback(struct ecm_tracker_instance *ti)$/;"	f
ecm_tracker_tcp_discard_all_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_discard_all_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_tcp_extract_mss	ecm_tracker_tcp.c	/^static bool ecm_tracker_tcp_extract_mss(struct sk_buff *skb, uint16_t *mss, struct ecm_tracker_ip_protocol_header *ecm_tcp_header)$/;"	f	file:
ecm_tracker_tcp_host_data	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_host_data {$/;"	s	file:
ecm_tracker_tcp_init	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_init);$/;"	v
ecm_tracker_tcp_init	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_init(struct ecm_tracker_tcp_instance *tti, int32_t data_limit, uint16_t mss_src_default, uint16_t mss_dest_default)$/;"	f
ecm_tracker_tcp_instance	ecm_tracker_tcp.h	/^struct ecm_tracker_tcp_instance {$/;"	s
ecm_tracker_tcp_internal_instance	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_internal_instance  {$/;"	s	file:
ecm_tracker_tcp_lock	ecm_tracker_tcp.c	/^spinlock_t ecm_tracker_tcp_lock;	\/* Global lock for the tracker globals *\/$/;"	v
ecm_tracker_tcp_module_exit	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_module_exit);$/;"	v
ecm_tracker_tcp_module_exit	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_module_exit(void)$/;"	f
ecm_tracker_tcp_module_init	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_module_init);$/;"	v
ecm_tracker_tcp_module_init	ecm_tracker_tcp.c	/^int ecm_tracker_tcp_module_init(void)$/;"	f
ecm_tracker_tcp_mss_get_callback	ecm_tracker_tcp.c	/^static bool ecm_tracker_tcp_mss_get_callback(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint16_t *mss)$/;"	f	file:
ecm_tracker_tcp_mss_get_method_t	ecm_tracker_tcp.h	/^typedef bool (*ecm_tracker_tcp_mss_get_method_t)(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender, uint16_t *mss);$/;"	t
ecm_tracker_tcp_reader_advance	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_advance);$/;"	v
ecm_tracker_tcp_reader_advance	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_advance(struct ecm_tracker_tcp_reader_instance *tri, uint32_t advancement)$/;"	f
ecm_tracker_tcp_reader_alloc	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_alloc);$/;"	v
ecm_tracker_tcp_reader_alloc	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_reader_instance *ecm_tracker_tcp_reader_alloc(void)$/;"	f
ecm_tracker_tcp_reader_count	ecm_tracker_tcp.c	/^int ecm_tracker_tcp_reader_count = 0;	\/* Counts the number of TCP readers right now *\/$/;"	v
ecm_tracker_tcp_reader_deref	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_deref);$/;"	v
ecm_tracker_tcp_reader_deref	ecm_tracker_tcp.c	/^int ecm_tracker_tcp_reader_deref(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_discard_preceding	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_discard_preceding);$/;"	v
ecm_tracker_tcp_reader_discard_preceding	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_discard_preceding(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_fwd_read_u8	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_fwd_read_u8);$/;"	v
ecm_tracker_tcp_reader_fwd_read_u8	ecm_tracker_tcp.c	/^uint8_t ecm_tracker_tcp_reader_fwd_read_u8(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_init	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_init);$/;"	v
ecm_tracker_tcp_reader_init	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_init(struct ecm_tracker_tcp_reader_instance *tri, struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender)$/;"	f
ecm_tracker_tcp_reader_instance	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_reader_instance {$/;"	s	file:
ecm_tracker_tcp_reader_position_get	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_position_get);$/;"	v
ecm_tracker_tcp_reader_position_get	ecm_tracker_tcp.c	/^uint32_t ecm_tracker_tcp_reader_position_get(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_position_set	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_position_set);$/;"	v
ecm_tracker_tcp_reader_position_set	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_position_set(struct ecm_tracker_tcp_reader_instance *tri, uint32_t offset)$/;"	f
ecm_tracker_tcp_reader_ref	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_ref);$/;"	v
ecm_tracker_tcp_reader_ref	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_ref(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_remain_get	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_remain_get);$/;"	v
ecm_tracker_tcp_reader_remain_get	ecm_tracker_tcp.c	/^uint32_t ecm_tracker_tcp_reader_remain_get(struct ecm_tracker_tcp_reader_instance *tri)$/;"	f
ecm_tracker_tcp_reader_retreat	ecm_tracker_tcp.c	/^EXPORT_SYMBOL(ecm_tracker_tcp_reader_retreat);$/;"	v
ecm_tracker_tcp_reader_retreat	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_reader_retreat(struct ecm_tracker_tcp_reader_instance *tri, uint32_t retreatment)$/;"	f
ecm_tracker_tcp_ref_callback	ecm_tracker_tcp.c	/^void ecm_tracker_tcp_ref_callback(struct ecm_tracker_instance *ti)$/;"	f
ecm_tracker_tcp_segment_add_callback	ecm_tracker_tcp.c	/^static bool ecm_tracker_tcp_segment_add_callback(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_tracker_tcp_segment_add_method_t	ecm_tracker_tcp.h	/^typedef bool (*ecm_tracker_tcp_segment_add_method_t)(struct ecm_tracker_tcp_instance *tti, ecm_tracker_sender_type_t sender,$/;"	t
ecm_tracker_tcp_sender_state	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_sender_state {$/;"	s	file:
ecm_tracker_tcp_sender_xml_state_get	ecm_tracker_tcp.c	/^static int ecm_tracker_tcp_sender_xml_state_get(char *buf, int buf_sz, ecm_tracker_sender_type_t sender, struct ecm_tracker_tcp_host_data *data, struct ecm_tracker_tcp_sender_state *state)$/;"	f	file:
ecm_tracker_tcp_skb_cb_format	ecm_tracker_tcp.c	/^struct ecm_tracker_tcp_skb_cb_format {$/;"	s	file:
ecm_tracker_tcp_state_get_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_state_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_state_t *src_state,$/;"	f	file:
ecm_tracker_tcp_state_update_callback	ecm_tracker_tcp.c	/^static void ecm_tracker_tcp_state_update_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_tcp_timer_group_from_state	ecm_tracker_tcp.c	/^static ecm_db_timer_group_t ecm_tracker_tcp_timer_group_from_state[] = {$/;"	v	file:
ecm_tracker_tcp_valid_flags	ecm_tracker_tcp.c	/^static uint32_t ecm_tracker_tcp_valid_flags[ECM_TRACKER_TCP_VALID_FLAGS_MAX] = {$/;"	v	file:
ecm_tracker_tcp_xml_state_get_callback	ecm_tracker_tcp.c	/^static int ecm_tracker_tcp_xml_state_get_callback(struct ecm_tracker_instance *ti, char *buf, int buf_sz)$/;"	f	file:
ecm_tracker_udp_alloc	ecm_tracker_udp.c	/^EXPORT_SYMBOL(ecm_tracker_udp_alloc);$/;"	v
ecm_tracker_udp_alloc	ecm_tracker_udp.c	/^struct ecm_tracker_udp_instance *ecm_tracker_udp_alloc(void)$/;"	f
ecm_tracker_udp_check_header_and_read	ecm_tracker_udp.c	/^EXPORT_SYMBOL(ecm_tracker_udp_check_header_and_read);$/;"	v
ecm_tracker_udp_check_header_and_read	ecm_tracker_udp.c	/^struct udphdr *ecm_tracker_udp_check_header_and_read(struct sk_buff *skb, struct ecm_tracker_ip_header *ip_hdr, struct udphdr *port_buffer)$/;"	f
ecm_tracker_udp_connection_state_matrix	ecm_tracker_udp.c	/^static ecm_tracker_connection_state_t ecm_tracker_udp_connection_state_matrix[ECM_TRACKER_SENDER_STATE_MAX][ECM_TRACKER_SENDER_STATE_MAX] =$/;"	v	file:
ecm_tracker_udp_count	ecm_tracker_udp.c	/^int ecm_tracker_udp_count = 0;		\/* Counts the number of UDP data trackers right now *\/$/;"	v
ecm_tracker_udp_data_limit_get_callback	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_data_limit_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_udp_data_limit_set_callback	ecm_tracker_udp.c	/^static void ecm_tracker_udp_data_limit_set_callback(struct ecm_tracker_instance *ti, int32_t data_limit)$/;"	f	file:
ecm_tracker_udp_data_read_callback	ecm_tracker_udp.c	/^static int ecm_tracker_udp_data_read_callback(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i,$/;"	f	file:
ecm_tracker_udp_data_read_method_t	ecm_tracker_udp.h	/^typedef int (*ecm_tracker_udp_data_read_method_t)(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer);$/;"	t
ecm_tracker_udp_data_size_get_callback	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_data_size_get_callback(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f	file:
ecm_tracker_udp_data_size_get_method_t	ecm_tracker_udp.h	/^typedef int32_t (*ecm_tracker_udp_data_size_get_method_t)(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i);$/;"	t
ecm_tracker_udp_data_total_get_callback	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_data_total_get_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_udp_datagram_add	ecm_tracker_udp.c	/^static bool ecm_tracker_udp_datagram_add(struct ecm_tracker_udp_internal_instance *utii, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_tracker_udp_datagram_add_callback	ecm_tracker_udp.c	/^static bool ecm_tracker_udp_datagram_add_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_udp_datagram_add_checked_callback	ecm_tracker_udp.c	/^static bool ecm_tracker_udp_datagram_add_checked_callback(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender,$/;"	f	file:
ecm_tracker_udp_datagram_add_method_t	ecm_tracker_udp.h	/^typedef bool (*ecm_tracker_udp_datagram_add_method_t)(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct ecm_tracker_ip_protocol_header *ecm_udp_header, struct udphdr *udp_header, struct sk_buff *skb);$/;"	t
ecm_tracker_udp_datagram_count_get	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_datagram_count_get(struct ecm_tracker_udp_internal_instance *utii, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_udp_datagram_count_get_callback	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_datagram_count_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender)$/;"	f	file:
ecm_tracker_udp_datagram_discard	ecm_tracker_udp.c	/^static void ecm_tracker_udp_datagram_discard(struct ecm_tracker_udp_internal_instance *utii, ecm_tracker_sender_type_t sender, int32_t n)$/;"	f	file:
ecm_tracker_udp_datagram_discard_callback	ecm_tracker_udp.c	/^static void ecm_tracker_udp_datagram_discard_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t n)$/;"	f	file:
ecm_tracker_udp_datagram_read	ecm_tracker_udp.c	/^int ecm_tracker_udp_datagram_read(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer)$/;"	f
ecm_tracker_udp_datagram_read_callback	ecm_tracker_udp.c	/^static int ecm_tracker_udp_datagram_read_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i, int32_t offset, int32_t size, void *buffer)$/;"	f	file:
ecm_tracker_udp_datagram_size_get	ecm_tracker_udp.c	/^int32_t ecm_tracker_udp_datagram_size_get(struct ecm_tracker_udp_instance *uti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f
ecm_tracker_udp_datagram_size_get_callback	ecm_tracker_udp.c	/^static int32_t ecm_tracker_udp_datagram_size_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, int32_t i)$/;"	f	file:
ecm_tracker_udp_deref	ecm_tracker_udp.c	/^static int ecm_tracker_udp_deref(struct ecm_tracker_udp_internal_instance *utii)$/;"	f	file:
ecm_tracker_udp_deref_callback	ecm_tracker_udp.c	/^int ecm_tracker_udp_deref_callback(struct ecm_tracker_instance *ti)$/;"	f
ecm_tracker_udp_discard_all	ecm_tracker_udp.c	/^void ecm_tracker_udp_discard_all(struct ecm_tracker_udp_internal_instance *utii)$/;"	f
ecm_tracker_udp_discard_all_callback	ecm_tracker_udp.c	/^static void ecm_tracker_udp_discard_all_callback(struct ecm_tracker_instance *ti)$/;"	f	file:
ecm_tracker_udp_init	ecm_tracker_udp.c	/^EXPORT_SYMBOL(ecm_tracker_udp_init);$/;"	v
ecm_tracker_udp_init	ecm_tracker_udp.c	/^void ecm_tracker_udp_init(struct ecm_tracker_udp_instance *uti, int32_t data_limit, int src_port, int dest_port)$/;"	f
ecm_tracker_udp_instance	ecm_tracker_udp.h	/^struct ecm_tracker_udp_instance {$/;"	s
ecm_tracker_udp_internal_instance	ecm_tracker_udp.c	/^struct ecm_tracker_udp_internal_instance {$/;"	s	file:
ecm_tracker_udp_lock	ecm_tracker_udp.c	/^spinlock_t ecm_tracker_udp_lock;		\/* Global lock for the tracker globals *\/$/;"	v
ecm_tracker_udp_module_exit	ecm_tracker_udp.c	/^EXPORT_SYMBOL(ecm_tracker_udp_module_exit);$/;"	v
ecm_tracker_udp_module_exit	ecm_tracker_udp.c	/^void ecm_tracker_udp_module_exit(void)$/;"	f
ecm_tracker_udp_module_init	ecm_tracker_udp.c	/^EXPORT_SYMBOL(ecm_tracker_udp_module_init);$/;"	v
ecm_tracker_udp_module_init	ecm_tracker_udp.c	/^int ecm_tracker_udp_module_init(void)$/;"	f
ecm_tracker_udp_ref	ecm_tracker_udp.c	/^static void ecm_tracker_udp_ref(struct ecm_tracker_udp_internal_instance *utii)$/;"	f	file:
ecm_tracker_udp_ref_callback	ecm_tracker_udp.c	/^void ecm_tracker_udp_ref_callback(struct ecm_tracker_instance *ti)$/;"	f
ecm_tracker_udp_skb_cb_format	ecm_tracker_udp.c	/^struct ecm_tracker_udp_skb_cb_format {$/;"	s	file:
ecm_tracker_udp_state_get_callback	ecm_tracker_udp.c	/^static void ecm_tracker_udp_state_get_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_state_t *src_state,$/;"	f	file:
ecm_tracker_udp_state_update_callback	ecm_tracker_udp.c	/^static void ecm_tracker_udp_state_update_callback(struct ecm_tracker_instance *ti, ecm_tracker_sender_type_t sender, struct ecm_tracker_ip_header *ip_hdr, struct sk_buff *skb)$/;"	f	file:
ecm_tracker_udp_xml_state_get_callback	ecm_tracker_udp.c	/^static int ecm_tracker_udp_xml_state_get_callback(struct ecm_tracker_instance *ti, char *buf, int buf_sz)$/;"	f	file:
ecm_tracker_xml_state_get_callback_t	ecm_tracker.h	/^typedef int (*ecm_tracker_xml_state_get_callback_t)(struct ecm_tracker_instance *ti, char *buf, int buf_sz);$/;"	t
egress_sender	ecm_classifier_default.c	/^	ecm_tracker_sender_type_t egress_sender;		\/* RO: Which sender is sending egress data *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
ethernet	ecm_db.c	/^		struct ecm_db_interface_info_ethernet ethernet;		\/* type == ECM_DB_IFACE_TYPE_ETHERNET *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_ethernet	file:
event_next	ecm_db.c	/^	struct ecm_db_listener_instance *event_next;$/;"	m	struct:ecm_db_listener_instance	typeref:struct:ecm_db_listener_instance::ecm_db_listener_instance	file:
feci	ecm_db.c	/^	struct ecm_front_end_connection_instance *feci;		\/* Front end instance specific to this connection *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_front_end_connection_instance	file:
fin_seq	ecm_tracker_tcp.c	/^	uint32_t fin_seq;				\/* Sequence number of the fin: used to detect when peer has ack'd the fin, transitioned this sender to closed. *\/$/;"	m	struct:ecm_tracker_tcp_sender_state	file:
final	ecm_db.c	/^	ecm_db_connection_final_callback_t final;		\/* Callback to owner when object is destroyed *\/$/;"	m	struct:ecm_db_connection_instance	file:
final	ecm_db.c	/^	ecm_db_host_final_callback_t final;		\/* Callback to owner when object is destroyed *\/$/;"	m	struct:ecm_db_host_instance	file:
final	ecm_db.c	/^	ecm_db_iface_final_callback_t final;		\/* Callback to owner when object is destroyed *\/$/;"	m	struct:ecm_db_iface_instance	file:
final	ecm_db.c	/^	ecm_db_mapping_final_callback_t final;				\/* Callback to owner when object is destroyed *\/$/;"	m	struct:ecm_db_mapping_instance	file:
final	ecm_db.c	/^	ecm_db_mapping_final_callback_t final;				\/* Final callback for this instance *\/$/;"	m	struct:ecm_db_listener_instance	file:
final	ecm_db.c	/^	ecm_db_node_final_callback_t final;		\/* Callback to owner when object is destroyed *\/$/;"	m	struct:ecm_db_node_instance	file:
flags	ecm_classifier_nl.c	/^	unsigned int flags;					\/* See ECM_CLASSIFIER_NL_F_* *\/$/;"	m	struct:ecm_classifier_nl_instance	file:
flags	ecm_db.c	/^	uint32_t flags;$/;"	m	struct:ecm_db_connection_instance	file:
flags	ecm_db.c	/^	uint32_t flags;$/;"	m	struct:ecm_db_host_instance	file:
flags	ecm_db.c	/^	uint32_t flags;$/;"	m	struct:ecm_db_iface_instance	file:
flags	ecm_db.c	/^	uint32_t flags;$/;"	m	struct:ecm_db_listener_instance	file:
flags	ecm_db.c	/^	uint32_t flags;$/;"	m	struct:ecm_db_mapping_instance	file:
flags	ecm_db.c	/^	uint8_t flags;$/;"	m	struct:ecm_db_node_instance	file:
flags	ecm_db_types.h	/^	uint32_t flags;					\/* Tunnel additional flags *\/$/;"	m	struct:ecm_db_interface_info_tunipip6
flow	ecm_classifier_hyfi.c	/^	struct hyfi_ecm_flow_data_t flow;$/;"	m	struct:ecm_classifier_hyfi_instance	typeref:struct:ecm_classifier_hyfi_instance::hyfi_ecm_flow_data_t	file:
flow_dscp	ecm_classifier.h	/^	uint8_t flow_dscp;				\/* DSCP mark for flow *\/$/;"	m	struct:ecm_classifier_process_response
flow_qos_tag	ecm_classifier.h	/^	uint32_t flow_qos_tag;				\/* QoS tag to use for the packet *\/$/;"	m	struct:ecm_classifier_process_response
flowlabel	ecm_db_types.h	/^	uint32_t flowlabel;				\/* Tunnel ipv6 flowlabel *\/$/;"	m	struct:ecm_db_interface_info_tunipip6
flush_happened	ecm_front_end_types.h	/^	bool flush_happened;			\/* A flush message was received from NSS before we received an ACK or NACK. (NSS Messaging sequence\/ordering workaround) *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
flush_happened_total	ecm_front_end_types.h	/^	uint32_t flush_happened_total;		\/* Total of times we see flush_happened *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
fn	ecm_db_types.h	/^	ecm_db_timer_group_entry_callback_t fn;			\/* Function called when timer expires *\/$/;"	m	struct:ecm_db_timer_group_entry
fragmented	ecm_tracker.h	/^	bool fragmented;		\/* True when fragmented *\/$/;"	m	struct:ecm_tracker_ip_header
from	ecm_db.c	/^	int from;$/;"	m	struct:ecm_db_mapping_instance	file:
from_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_connections;		\/* list of connections made from this host mapping *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_connection_instance	file:
from_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_connections;		\/* list of connections made from this interface *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_connection_instance	file:
from_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_connections;		\/* list of connections made from this node *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_connection_instance	file:
from_connections_count	ecm_db.c	/^	int from_connections_count;					\/* Number of connections in the from_connections list *\/$/;"	m	struct:ecm_db_node_instance	file:
from_data_total	ecm_classifier_default.h	/^	uint32_t from_data_total;		\/* Amount of bytes sent by 'from' *\/$/;"	m	struct:ecm_classifier_default_sync
from_data_total	ecm_db.c	/^	uint64_t from_data_total;					\/* Total of data sent by this mapping *\/$/;"	m	struct:ecm_db_mapping_instance	file:
from_data_total	ecm_db.c	/^	uint64_t from_data_total;				\/* Totals of data as sent by the 'from' side of this connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_data_total	ecm_db.c	/^	uint64_t from_data_total;			\/* Total of data sent by this Interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
from_data_total	ecm_db.c	/^	uint64_t from_data_total;			\/* Total of data sent by this host *\/$/;"	m	struct:ecm_db_host_instance	file:
from_data_total	ecm_db.c	/^	uint64_t from_data_total;			\/* Total of data sent by this node *\/$/;"	m	struct:ecm_db_node_instance	file:
from_data_total_dropped	ecm_db.c	/^	uint64_t from_data_total_dropped;			\/* Total data sent by the 'from' side that we purposely dropped - the 'to' side has not seen this data *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_data_total_dropped	ecm_db.c	/^	uint64_t from_data_total_dropped;$/;"	m	struct:ecm_db_host_instance	file:
from_data_total_dropped	ecm_db.c	/^	uint64_t from_data_total_dropped;$/;"	m	struct:ecm_db_iface_instance	file:
from_data_total_dropped	ecm_db.c	/^	uint64_t from_data_total_dropped;$/;"	m	struct:ecm_db_mapping_instance	file:
from_data_total_dropped	ecm_db.c	/^	uint64_t from_data_total_dropped;$/;"	m	struct:ecm_db_node_instance	file:
from_interface_first	ecm_db.c	/^	int32_t from_interface_first;				\/* The index of the first interface in the list *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_interface_set	ecm_db.c	/^	bool from_interface_set;				\/* True when a list has been set - even if there is NO list, it's still deliberately set that way. *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_interfaces	ecm_db.c	/^	struct ecm_db_iface_instance *from_interfaces[ECM_DB_IFACE_HEIRARCHY_MAX];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_iface_instance	file:
from_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_nat_connections;	\/* list of NAT connections made from this host mapping *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_connection_instance	file:
from_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_nat_connections;	\/* list of NAT connections made from this interface *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_connection_instance	file:
from_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *from_nat_connections;	\/* list of NAT connections made from this node *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_connection_instance	file:
from_nat_connections_count	ecm_db.c	/^	int from_nat_connections_count;					\/* Number of connections in the from_nat_connections list *\/$/;"	m	struct:ecm_db_node_instance	file:
from_nat_interface_first	ecm_db.c	/^	int32_t from_nat_interface_first;			\/* The index of the first interface in the list *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_nat_interface_set	ecm_db.c	/^	bool from_nat_interface_set;				\/* True when a list has been set - even if there is NO list, it's still deliberately set that way. *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_nat_interfaces	ecm_db.c	/^	struct ecm_db_iface_instance *from_nat_interfaces[ECM_DB_IFACE_HEIRARCHY_MAX];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_iface_instance	file:
from_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *from_nat_next;	\/* Next connection made from the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
from_nat_node	ecm_db.c	/^	struct ecm_db_node_instance *from_nat_node;		\/* Node from which this connection was established *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_node_instance	file:
from_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *from_nat_prev;	\/* Previous connection made from the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
from_next	ecm_db.c	/^	struct ecm_db_connection_instance *from_next;		\/* Next connection made from the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
from_node	ecm_db.c	/^	struct ecm_db_node_instance *from_node;			\/* Node from which this connection was established *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_node_instance	file:
from_packet_total	ecm_db.c	/^	uint64_t from_packet_total;					\/* Total of packets sent by this mapping *\/$/;"	m	struct:ecm_db_mapping_instance	file:
from_packet_total	ecm_db.c	/^	uint64_t from_packet_total;				\/* Totals of packets as sent by the 'from' side of this connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_packet_total	ecm_db.c	/^	uint64_t from_packet_total;			\/* Total of packets sent by this Interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
from_packet_total	ecm_db.c	/^	uint64_t from_packet_total;			\/* Total of packets sent by this host *\/$/;"	m	struct:ecm_db_host_instance	file:
from_packet_total	ecm_db.c	/^	uint64_t from_packet_total;			\/* Total of packets sent by this node *\/$/;"	m	struct:ecm_db_node_instance	file:
from_packet_total_dropped	ecm_db.c	/^	uint64_t from_packet_total_dropped;			\/* Total packets sent by the 'from' side that we purposely dropped - the 'to' side has not seen this data *\/$/;"	m	struct:ecm_db_connection_instance	file:
from_packet_total_dropped	ecm_db.c	/^	uint64_t from_packet_total_dropped;$/;"	m	struct:ecm_db_host_instance	file:
from_packet_total_dropped	ecm_db.c	/^	uint64_t from_packet_total_dropped;$/;"	m	struct:ecm_db_iface_instance	file:
from_packet_total_dropped	ecm_db.c	/^	uint64_t from_packet_total_dropped;$/;"	m	struct:ecm_db_mapping_instance	file:
from_packet_total_dropped	ecm_db.c	/^	uint64_t from_packet_total_dropped;$/;"	m	struct:ecm_db_node_instance	file:
from_prev	ecm_db.c	/^	struct ecm_db_connection_instance *from_prev;		\/* Previous connection made from the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
future	ecm_tracker_tcp.c	/^	struct sk_buff *future;				\/* A list of skb's that are in the "future" (sequence space wise) and need more sequence space$/;"	m	struct:ecm_tracker_tcp_host_data	typeref:struct:ecm_tracker_tcp_host_data::sk_buff	file:
generations	ecm_db.c	/^	uint32_t generations;					\/* Tracks how many times re-generation was seen for this connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
group	ecm_db_types.h	/^	ecm_db_timer_group_t group;				\/* The timer group to which this entry belongs, if this is ECM_DB_TIMER_GROUPS_MAX then the timer is not running *\/$/;"	m	struct:ecm_db_timer_group_entry
h	ecm_tracker.h	/^	} h;$/;"	m	struct:ecm_tracker_ip_header	typeref:union:ecm_tracker_ip_header::__anon3
hash_index	ecm_db.c	/^	ecm_db_connection_hash_t hash_index;			\/* The hash table slot whose chain of connections this is inserted into *\/$/;"	m	struct:ecm_db_connection_instance	file:
hash_index	ecm_db.c	/^	ecm_db_host_hash_t hash_index;$/;"	m	struct:ecm_db_host_instance	file:
hash_index	ecm_db.c	/^	ecm_db_iface_hash_t hash_index;$/;"	m	struct:ecm_db_iface_instance	file:
hash_index	ecm_db.c	/^	ecm_db_mapping_hash_t hash_index;$/;"	m	struct:ecm_db_mapping_instance	file:
hash_index	ecm_db.c	/^	ecm_db_node_hash_t hash_index;$/;"	m	struct:ecm_db_node_instance	file:
hash_next	ecm_db.c	/^	struct ecm_db_connection_instance *hash_next;		\/* Next connection in chain *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
hash_next	ecm_db.c	/^	struct ecm_db_host_instance *hash_next;		\/* Next host in the chain of hosts *\/$/;"	m	struct:ecm_db_host_instance	typeref:struct:ecm_db_host_instance::ecm_db_host_instance	file:
hash_next	ecm_db.c	/^	struct ecm_db_iface_instance *hash_next;	\/* Next Interface in the chain of Interfaces *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_iface_instance	file:
hash_next	ecm_db.c	/^	struct ecm_db_mapping_instance *hash_next;			\/* Next mapping in the chain of mappings *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
hash_next	ecm_db.c	/^	struct ecm_db_node_instance *hash_next;		\/* Next node in the chain of nodes *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
hash_prev	ecm_db.c	/^	struct ecm_db_connection_instance *hash_prev;		\/* Previous connection in chain *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
hash_prev	ecm_db.c	/^	struct ecm_db_host_instance *hash_prev;		\/* previous host in the chain of hosts *\/$/;"	m	struct:ecm_db_host_instance	typeref:struct:ecm_db_host_instance::ecm_db_host_instance	file:
hash_prev	ecm_db.c	/^	struct ecm_db_iface_instance *hash_prev;	\/* previous Interface in the chain of Interfaces *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_iface_instance	file:
hash_prev	ecm_db.c	/^	struct ecm_db_mapping_instance *hash_prev;			\/* previous mapping in the chain of mappings *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
hash_prev	ecm_db.c	/^	struct ecm_db_node_instance *hash_prev;		\/* previous node in the chain of nodes *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
head	ecm_db.c	/^	struct ecm_db_timer_group_entry *head;		\/* Most recently used entry in this timer group *\/$/;"	m	struct:ecm_db_timer_group	typeref:struct:ecm_db_timer_group::ecm_db_timer_group_entry	file:
header_helper	ecm_tracker.c	/^	ecm_tracker_ip_header_helper_method_t header_helper;	\/* A function used to help process the header, e.g. its size etc. When a NULL helper is located, header processing stops. *\/$/;"	m	struct:ecm_tracker_ip_protocols	file:
header_size	ecm_tracker.h	/^	uint16_t header_size;			\/* Size of the protocol header *\/$/;"	m	struct:ecm_tracker_ip_protocol_header
headers	ecm_tracker.h	/^	struct ecm_tracker_ip_protocol_header headers[ECM_TRACKER_IP_PROTOCOL_TYPE_COUNT];$/;"	m	struct:ecm_tracker_ip_header	typeref:struct:ecm_tracker_ip_header::ecm_tracker_ip_protocol_header
hi	ecm_db.c	/^	struct ecm_db_host_instance *hi;		\/* All hosts list iterator *\/$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_host_instance	file:
hop_limit	ecm_db_types.h	/^	uint8_t  hop_limit;				\/* Tunnel ipv6 hop limit *\/$/;"	m	struct:ecm_db_interface_info_tunipip6
host	ecm_db.c	/^	struct ecm_db_host_instance *host;				\/* The host to which this mapping relates *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_host_instance	file:
host_added	ecm_db.c	/^	ecm_db_host_listener_added_callback_t host_added;$/;"	m	struct:ecm_db_listener_instance	file:
host_hash_index	ecm_db.c	/^	int host_hash_index;				\/* Host hash table lengths iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
host_removed	ecm_db.c	/^	ecm_db_host_listener_removed_callback_t host_removed;$/;"	m	struct:ecm_db_listener_instance	file:
hyfi_state	ecm_classifier_hyfi.c	/^	uint32_t hyfi_state;$/;"	m	struct:ecm_classifier_hyfi_instance	file:
iface	ecm_db.c	/^	struct ecm_db_iface_instance *iface;		\/* The interface to which this node relates *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_iface_instance	file:
iface_added	ecm_db.c	/^	ecm_db_iface_listener_added_callback_t iface_added;$/;"	m	struct:ecm_db_listener_instance	file:
iface_from_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *iface_from_nat_next;	\/* Next connection made from the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_from_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *iface_from_nat_prev;	\/* Previous connection made from the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_from_next	ecm_db.c	/^	struct ecm_db_connection_instance *iface_from_next;	\/* Next connection made from the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_from_prev	ecm_db.c	/^	struct ecm_db_connection_instance *iface_from_prev;	\/* Previous connection made from the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_hash_index	ecm_db.c	/^	int iface_hash_index;				\/* Interface hash table lengths iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
iface_removed	ecm_db.c	/^	ecm_db_iface_listener_removed_callback_t iface_removed;$/;"	m	struct:ecm_db_listener_instance	file:
iface_to_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *iface_to_nat_next;	\/* Next connection made to the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_to_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *iface_to_nat_prev;	\/* Previous connection made to the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_to_next	ecm_db.c	/^	struct ecm_db_connection_instance *iface_to_next;	\/* Next connection made to the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
iface_to_prev	ecm_db.c	/^	struct ecm_db_connection_instance *iface_to_prev;	\/* Previous connection made to the same interface *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
ii	ecm_db.c	/^	struct ecm_db_iface_instance *ii;		\/* All interfaces list iterator *\/$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_iface_instance	file:
in	ecm_classifier_nl.h	/^	struct in_addr in;$/;"	m	union:ecm_cl_nl_genl_attr_ip	typeref:struct:ecm_cl_nl_genl_attr_ip::in_addr
in6	ecm_classifier_nl.h	/^	struct in6_addr in6;$/;"	m	union:ecm_cl_nl_genl_attr_ip	typeref:struct:ecm_cl_nl_genl_attr_ip::in6_addr
in_order	ecm_tracker_tcp.c	/^	struct sk_buff *in_order;			\/* A list of skb's tracked in our recvd_order list in sequence space order that we can read from.$/;"	m	struct:ecm_tracker_tcp_host_data	typeref:struct:ecm_tracker_tcp_host_data::sk_buff	file:
in_order_count	ecm_tracker_tcp.c	/^	int32_t in_order_count;				\/* The number of skb's in the in order list *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
in_order_last	ecm_tracker_tcp.c	/^	struct sk_buff *in_order_last;			\/* Fast appending of in-order data buffers *\/$/;"	m	struct:ecm_tracker_tcp_host_data	typeref:struct:ecm_tracker_tcp_host_data::sk_buff	file:
ingress_sender	ecm_classifier_default.c	/^	ecm_tracker_sender_type_t ingress_sender;		\/* RO: Which sender is sending ingress data *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
interface_identifier	ecm_db.c	/^	int32_t interface_identifier;			\/* RO: The operating system dependent identifier of this interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
ip_addr_t	ecm_types.h	/^typedef uint32_t ip_addr_t[4];$/;"	t
ip_header_length	ecm_tracker.h	/^	uint32_t ip_header_length;	\/* Length of the IP header plus any variable sized intrinsically attached options *\/$/;"	m	struct:ecm_tracker_ip_header
ip_protocol	ecm_tracker.c	/^	uint8_t ip_protocol;					\/* The IP protocol we want to detect and record its information *\/$/;"	m	struct:ecm_tracker_ip_protocols	file:
ipsec_tunnel	ecm_db.c	/^		struct ecm_db_interface_info_ipsec_tunnel ipsec_tunnel;	\/* type == ECM_DB_IFACE_TYPE_IPSEC_TUNNEL *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_ipsec_tunnel	file:
is_defunct	ecm_front_end_ipv4.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
is_defunct	ecm_front_end_ipv4.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
is_defunct	ecm_front_end_ipv4.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
is_defunct	ecm_front_end_ipv6.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
is_defunct	ecm_front_end_ipv6.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
is_defunct	ecm_front_end_ipv6.c	/^	bool is_defunct;					\/* True if the connection has become defunct *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
is_routed	ecm_db.c	/^	bool is_routed;						\/* RO: True when connection is routed, false when not *\/$/;"	m	struct:ecm_db_connection_instance	file:
is_v4	ecm_tracker.h	/^	bool is_v4;			\/* True when v4, else v6 *\/$/;"	m	struct:ecm_tracker_ip_header
iteration_count	ecm_db.c	/^	int iteration_count;				\/* >0 if something is examining this list entry and it may not be unlinked.  The connection will persist. *\/$/;"	m	struct:ecm_db_connection_classifier_type_assignment	file:
lag	ecm_db.c	/^		struct ecm_db_interface_info_lag lag;			\/* type == ECM_DB_IFACE_TYPE_LAG *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_lag	file:
last_process_response_get	ecm_classifier.h	/^	ecm_classifier_last_process_response_get_callback_t last_process_response_get;$/;"	m	struct:ecm_classifier_instance
lock	ecm_front_end_ipv4.c	/^	spinlock_t lock;					\/* Lock for structure data *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
lock	ecm_front_end_ipv4.c	/^	spinlock_t lock;					\/* Lock for structure data *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
lock	ecm_front_end_ipv4.c	/^	spinlock_t lock;					\/* Lock for structure data *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
lock	ecm_front_end_ipv6.c	/^	spinlock_t lock;					\/* Lock for structure data *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
lock	ecm_front_end_ipv6.c	/^	spinlock_t lock;					\/* Lock for structure dtaa *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
lock	ecm_front_end_ipv6.c	/^	spinlock_t lock;					\/* Lock for structure dtaa *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
lock	ecm_tracker_datagram.c	/^	spinlock_t lock;			\/* lock *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
lock	ecm_tracker_tcp.c	/^	spinlock_t lock;$/;"	m	struct:ecm_tracker_tcp_internal_instance	file:
lock	ecm_tracker_tcp.c	/^	spinlock_t lock;$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
lock	ecm_tracker_udp.c	/^	spinlock_t lock;			\/* lock *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
loopback	ecm_db.c	/^		struct ecm_db_interface_info_loopback loopback;		\/* type == ECM_DB_IFACE_TYPE_LOOPBACK *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_loopback	file:
magic	ecm_classifier_default.c	/^	uint16_t magic;$/;"	m	struct:ecm_classifier_default_internal_instance	file:
magic	ecm_classifier_default.c	/^	uint16_t magic;$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
magic	ecm_classifier_dscp.c	/^	uint16_t magic;$/;"	m	struct:ecm_classifier_dscp_instance	file:
magic	ecm_classifier_hyfi.c	/^	uint16_t magic;$/;"	m	struct:ecm_classifier_hyfi_instance	file:
magic	ecm_classifier_nl.c	/^	uint16_t magic;$/;"	m	struct:ecm_classifier_nl_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_connection_classifier_type_assignment	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_connection_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_host_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_iface_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_listener_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_mapping_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_node_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_state_file_instance	file:
magic	ecm_db.c	/^	uint16_t magic;$/;"	m	struct:ecm_db_timer_group	file:
magic	ecm_front_end_ipv4.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
magic	ecm_front_end_ipv4.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
magic	ecm_front_end_ipv4.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
magic	ecm_front_end_ipv6.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
magic	ecm_front_end_ipv6.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
magic	ecm_front_end_ipv6.c	/^	uint16_t magic;$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
magic	ecm_tracker_datagram.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
magic	ecm_tracker_tcp.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_tcp_internal_instance	file:
magic	ecm_tracker_tcp.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
magic	ecm_tracker_tcp.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	file:
magic	ecm_tracker_udp.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
magic	ecm_tracker_udp.c	/^	uint16_t magic;$/;"	m	struct:ecm_tracker_udp_skb_cb_format	file:
mapping_added	ecm_db.c	/^	ecm_db_mapping_listener_added_callback_t mapping_added;$/;"	m	struct:ecm_db_listener_instance	file:
mapping_count	ecm_db.c	/^	int mapping_count;				\/* Number of mappings in the mapping list *\/$/;"	m	struct:ecm_db_host_instance	file:
mapping_from	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_from;		\/* The connection was established from this mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_mapping_instance	file:
mapping_hash_index	ecm_db.c	/^	int mapping_hash_index;				\/* Mapping hash table lengths iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
mapping_nat_from	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_nat_from;	\/* The connection was established from this mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_mapping_instance	file:
mapping_nat_to	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_nat_to;		\/* The connection was established to this mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_mapping_instance	file:
mapping_next	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_next;			\/* Next mapping in the list of mappings for the host *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
mapping_prev	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_prev;			\/* previous mapping in the list of mappings for the host *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
mapping_removed	ecm_db.c	/^	ecm_db_mapping_listener_removed_callback_t mapping_removed;$/;"	m	struct:ecm_db_listener_instance	file:
mapping_to	ecm_db.c	/^	struct ecm_db_mapping_instance *mapping_to;		\/* The connection was established to this mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_mapping_instance	file:
mappings	ecm_db.c	/^	struct ecm_db_mapping_instance *mappings;	\/* Mappings made on this host *\/$/;"	m	struct:ecm_db_host_instance	typeref:struct:ecm_db_host_instance::ecm_db_mapping_instance	file:
mi	ecm_db.c	/^	struct ecm_db_mapping_instance *mi;		\/* All mappings list iterator *\/$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_mapping_instance	file:
msg_buffer	ecm_classifier_default.c	/^	char msg_buffer[ECM_CLASSIFIER_DEFAULT_STATE_FILE_BUFFER_SIZE];	\/* Used to hold the current state message being output *\/$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
msg_buffer	ecm_db.c	/^	char msg_buffer[ECM_DB_STATE_FILE_BUFFER_SIZE];	\/* Used to hold the current state message being output *\/$/;"	m	struct:ecm_db_state_file_instance	file:
msg_len	ecm_classifier_default.c	/^	int msg_len;							\/* Length of the buffer still to be written out *\/$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
msg_len	ecm_db.c	/^	int msg_len;					\/* Length of the buffer still to be written out *\/$/;"	m	struct:ecm_db_state_file_instance	file:
msgp	ecm_classifier_default.c	/^	char *msgp;							\/* Points into the msg buffer as we output it piece by piece *\/$/;"	m	struct:ecm_classifier_default_state_file_instance	file:
msgp	ecm_db.c	/^	char *msgp;					\/* Points into the msg buffer as we output it piece by piece *\/$/;"	m	struct:ecm_db_state_file_instance	file:
mss	ecm_tracker_tcp.c	/^	uint16_t mss;					\/* MSS as sent by that host in a SYN packet *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
mss_get	ecm_tracker_tcp.h	/^	ecm_tracker_tcp_mss_get_method_t mss_get;			\/* Get the MSS as sent BY the given target i.e. the maximum number of *\/$/;"	m	struct:ecm_tracker_tcp_instance
mss_seen	ecm_tracker_tcp.c	/^	bool mss_seen;					\/* true if the mss was from a SYN packet rather than an assigned default *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
mtu	ecm_db.c	/^	int32_t mtu;					\/* Interface MTU *\/$/;"	m	struct:ecm_db_iface_instance	file:
name	ecm_db.c	/^	char name[IFNAMSIZ];				\/* Name of interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
name	ecm_tracker.c	/^	char *name;						\/* Visual name of the protocol *\/$/;"	m	struct:ecm_tracker_ip_protocols	file:
nat_from	ecm_db.c	/^	int nat_from;$/;"	m	struct:ecm_db_mapping_instance	file:
nat_to	ecm_db.c	/^	int nat_to;$/;"	m	struct:ecm_db_mapping_instance	file:
next	ecm_classifier_dscp.c	/^	struct ecm_classifier_dscp_instance *next;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_dscp_instance	typeref:struct:ecm_classifier_dscp_instance::ecm_classifier_dscp_instance	file:
next	ecm_classifier_hyfi.c	/^	struct ecm_classifier_hyfi_instance *next;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_hyfi_instance	typeref:struct:ecm_classifier_hyfi_instance::ecm_classifier_hyfi_instance	file:
next	ecm_classifier_nl.c	/^	struct ecm_classifier_nl_instance *next;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_nl_instance	typeref:struct:ecm_classifier_nl_instance::ecm_classifier_nl_instance	file:
next	ecm_db.c	/^	struct ecm_db_connection_instance *next;		\/* Next instance in global list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
next	ecm_db.c	/^	struct ecm_db_connection_instance *next;	\/* Next connection assigned to a classifier of this type *\/$/;"	m	struct:ecm_db_connection_classifier_type_assignment	typeref:struct:ecm_db_connection_classifier_type_assignment::ecm_db_connection_instance	file:
next	ecm_db.c	/^	struct ecm_db_host_instance *next;		\/* Next instance in global list *\/$/;"	m	struct:ecm_db_host_instance	typeref:struct:ecm_db_host_instance::ecm_db_host_instance	file:
next	ecm_db.c	/^	struct ecm_db_iface_instance *next;		\/* Next instance in global list *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_iface_instance	file:
next	ecm_db.c	/^	struct ecm_db_listener_instance *next;$/;"	m	struct:ecm_db_listener_instance	typeref:struct:ecm_db_listener_instance::ecm_db_listener_instance	file:
next	ecm_db.c	/^	struct ecm_db_mapping_instance *next;				\/* Next instance in global list *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
next	ecm_db.c	/^	struct ecm_db_node_instance *next;		\/* Next instance in global list *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
next	ecm_db_types.h	/^	struct ecm_db_timer_group_entry *next;			\/* Link to the next entry in the timer group chain *\/$/;"	m	struct:ecm_db_timer_group_entry	typeref:struct:ecm_db_timer_group_entry::ecm_db_timer_group_entry
next	ecm_tracker_tcp.c	/^	struct sk_buff *next;		\/* Next sk buff in the recvd_order list *\/$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	typeref:struct:ecm_tracker_tcp_skb_cb_format::sk_buff	file:
ni	ecm_db.c	/^	struct ecm_db_node_instance *ni;		\/* All nodes list iterator *\/$/;"	m	struct:ecm_db_state_file_instance	typeref:struct:ecm_db_state_file_instance::ecm_db_node_instance	file:
no_action_seen	ecm_front_end_types.h	/^	uint32_t no_action_seen;		\/* Count of times consecutive  acceleration was ended by the NSS itself without any offload action *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
no_action_seen_limit	ecm_front_end_types.h	/^	uint32_t no_action_seen_limit;		\/* Limit on consecutive no-action at which point offload permanently fails out *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
no_action_seen_total	ecm_front_end_types.h	/^	uint32_t no_action_seen_total;		\/* Total of times acceleration was ended by the NSS itself without any offload action *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
node_added	ecm_db.c	/^	ecm_db_node_listener_added_callback_t node_added;$/;"	m	struct:ecm_db_listener_instance	file:
node_count	ecm_db.c	/^	int node_count;					\/* Number of Nodes in the nodes list *\/$/;"	m	struct:ecm_db_iface_instance	file:
node_from_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *node_from_nat_next;	\/* Next connection in the nodes from_nat_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_from_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *node_from_nat_prev;	\/* Prev connection in the nodes from_nat_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_from_next	ecm_db.c	/^	struct ecm_db_connection_instance *node_from_next;	\/* Next connection in the nodes from_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_from_prev	ecm_db.c	/^	struct ecm_db_connection_instance *node_from_prev;	\/* Prev connection in the nodes from_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_hash_index	ecm_db.c	/^	int node_hash_index;				\/* Node hash table lengths iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
node_next	ecm_db.c	/^	struct ecm_db_node_instance *node_next;		\/* The next node within the same iface nodes list *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
node_prev	ecm_db.c	/^	struct ecm_db_node_instance *node_prev;		\/* The previous node within the same iface nodes list *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
node_removed	ecm_db.c	/^	ecm_db_node_listener_removed_callback_t node_removed;$/;"	m	struct:ecm_db_listener_instance	file:
node_to_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *node_to_nat_next;	\/* Next connection in the nodes to_nat_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_to_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *node_to_nat_prev;	\/* Prev connection in the nodes to_nat_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_to_next	ecm_db.c	/^	struct ecm_db_connection_instance *node_to_next;	\/* Next connection in the nodes to_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
node_to_prev	ecm_db.c	/^	struct ecm_db_connection_instance *node_to_prev;	\/* Prev connection in the nodes to_connections list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
nodes	ecm_db.c	/^	struct ecm_db_node_instance *nodes;		\/* Nodes associated with this Interface *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_node_instance	file:
nss_interface_identifier	ecm_db.c	/^	int32_t nss_interface_identifier;		\/* RO: The NSS identifier of this interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
nss_nack	ecm_front_end_types.h	/^	uint32_t nss_nack;			\/* Count of consecutive times driver failed to ack *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
nss_nack_limit	ecm_front_end_types.h	/^	uint32_t nss_nack_limit;		\/* Limit on consecutive nacks at which point offload permanently fails out *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
nss_nack_total	ecm_front_end_types.h	/^	uint32_t nss_nack_total;		\/* Total times NSS NAK's an accel command *\/$/;"	m	struct:ecm_front_end_connection_mode_stats
num_seqs	ecm_tracker_tcp.c	/^	uint32_t num_seqs;				\/* Number of sequences from first *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
num_seqs	ecm_tracker_tcp.c	/^	uint32_t num_seqs;		\/* Number of DATA BYTES\/sequences, i.e. the number of sequences from seq_no. *\/$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	file:
obj	Makefile	/^obj ?= .$/;"	m
offset	ecm_tracker.h	/^	uint16_t offset;			\/* Offset from the start of the skb where this header is located *\/$/;"	m	struct:ecm_tracker_ip_protocol_header
offset	ecm_tracker_tcp.c	/^	uint32_t offset;				\/* Logical offset from a start of 0 - i.e. from start of tracker data.$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
offset	ecm_tracker_tcp.c	/^	uint32_t offset;		\/* Offset from skb->data to seq_no (i.e. header size we must skip to get to data) *\/$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	file:
on_link	ecm_db.c	/^	bool on_link;					\/* RO: false when this host is reached via a gateway *\/$/;"	m	struct:ecm_db_host_instance	file:
os_specific_ident	ecm_db_types.h	/^	uint32_t os_specific_ident;			\/* Operating system specific identifier (known only by front end) *\/$/;"	m	struct:ecm_db_interface_info_ipsec_tunnel
os_specific_ident	ecm_db_types.h	/^	uint32_t os_specific_ident;			\/* Operating system specific identifier (known only by front end) *\/$/;"	m	struct:ecm_db_interface_info_loopback
os_specific_ident	ecm_db_types.h	/^	uint32_t os_specific_ident;			\/* Operating system specific identifier (known only by front end) *\/$/;"	m	struct:ecm_db_interface_info_unknown
output_mask	ecm_db.c	/^	int output_mask;				\/* The content types wanted by the user *\/$/;"	m	struct:ecm_db_state_file_instance	file:
payload_length	ecm_tracker.h	/^	uint32_t payload_length;	\/* total_length - ip_header_length *\/$/;"	m	struct:ecm_tracker_ip_header
pending_unassign	ecm_db.c	/^	bool pending_unassign;				\/* True when the connection has been unassigned from the type, when iteration_count drops to 0 it may be removed from the list *\/$/;"	m	struct:ecm_db_connection_classifier_type_assignment	file:
port	ecm_db.c	/^	int port;							\/* RO: The port number on the host - only applicable for mapping protocols that are port based *\/$/;"	m	struct:ecm_db_mapping_instance	file:
pppoe	ecm_db.c	/^		struct ecm_db_interface_info_pppoe pppoe;		\/* type == ECM_DB_IFACE_TYPE_PPPOE *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_pppoe	file:
pppoe_session_id	ecm_db_types.h	/^       	uint16_t pppoe_session_id;			\/* PPPoE session ID on this interface, when applicable *\/$/;"	m	struct:ecm_db_interface_info_pppoe
prefix	ecm_db_types.h	/^	uint32_t prefix[4];				\/* 6rd prefix *\/$/;"	m	struct:ecm_db_interface_info_sit
prefixlen	ecm_db_types.h	/^	uint16_t prefixlen;				\/* 6rd prefix len *\/$/;"	m	struct:ecm_db_interface_info_sit
prev	ecm_classifier_dscp.c	/^	struct ecm_classifier_dscp_instance *prev;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_dscp_instance	typeref:struct:ecm_classifier_dscp_instance::ecm_classifier_dscp_instance	file:
prev	ecm_classifier_hyfi.c	/^	struct ecm_classifier_hyfi_instance *prev;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_hyfi_instance	typeref:struct:ecm_classifier_hyfi_instance::ecm_classifier_hyfi_instance	file:
prev	ecm_classifier_nl.c	/^	struct ecm_classifier_nl_instance *prev;		\/* Next classifier state instance (for accouting and reporting purposes) *\/$/;"	m	struct:ecm_classifier_nl_instance	typeref:struct:ecm_classifier_nl_instance::ecm_classifier_nl_instance	file:
prev	ecm_db.c	/^	struct ecm_db_connection_instance *prev;		\/* Previous instance in global list *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
prev	ecm_db.c	/^	struct ecm_db_connection_instance *prev;	\/* Previous connection assigned to a classifier of this type *\/$/;"	m	struct:ecm_db_connection_classifier_type_assignment	typeref:struct:ecm_db_connection_classifier_type_assignment::ecm_db_connection_instance	file:
prev	ecm_db.c	/^	struct ecm_db_host_instance *prev;		\/* Previous instance in global list *\/$/;"	m	struct:ecm_db_host_instance	typeref:struct:ecm_db_host_instance::ecm_db_host_instance	file:
prev	ecm_db.c	/^	struct ecm_db_iface_instance *prev;		\/* Previous instance in global list *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_iface_instance	file:
prev	ecm_db.c	/^	struct ecm_db_mapping_instance *prev;				\/* Previous instance in global list *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_mapping_instance	file:
prev	ecm_db.c	/^	struct ecm_db_node_instance *prev;		\/* Previous instance in global list *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_node_instance	file:
prev	ecm_db_types.h	/^	struct ecm_db_timer_group_entry *prev;			\/* Link to the previous entry in the timer group chain *\/$/;"	m	struct:ecm_db_timer_group_entry	typeref:struct:ecm_db_timer_group_entry::ecm_db_timer_group_entry
prev	ecm_tracker_tcp.c	/^	struct sk_buff *prev;		\/* Previous sk buff in the recvd_order  *\/$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	typeref:struct:ecm_tracker_tcp_skb_cb_format::sk_buff	file:
process	ecm_classifier.h	/^	ecm_classifier_process_callback_t process;	\/* Process new skb *\/$/;"	m	struct:ecm_classifier_instance
process	ecm_classifier_default.h	/^	ecm_classifier_default_process_callback_t process;		\/* Process new data for connection - Used ONLY by front ends *\/$/;"	m	struct:ecm_classifier_default_instance
process_actions	ecm_classifier.h	/^	uint32_t process_actions;			\/* Actions this process response contains *\/$/;"	m	struct:ecm_classifier_process_response
process_response	ecm_classifier_default.c	/^	struct ecm_classifier_process_response process_response;$/;"	m	struct:ecm_classifier_default_internal_instance	typeref:struct:ecm_classifier_default_internal_instance::ecm_classifier_process_response	file:
process_response	ecm_classifier_dscp.c	/^	struct ecm_classifier_process_response process_response;\/* Last process response computed *\/$/;"	m	struct:ecm_classifier_dscp_instance	typeref:struct:ecm_classifier_dscp_instance::ecm_classifier_process_response	file:
process_response	ecm_classifier_hyfi.c	/^	struct ecm_classifier_process_response process_response;\/* Last process response computed *\/$/;"	m	struct:ecm_classifier_hyfi_instance	typeref:struct:ecm_classifier_hyfi_instance::ecm_classifier_process_response	file:
process_response	ecm_classifier_nl.c	/^	struct ecm_classifier_process_response process_response;\/* Last process response computed *\/$/;"	m	struct:ecm_classifier_nl_instance	typeref:struct:ecm_classifier_nl_instance::ecm_classifier_process_response	file:
proto	ecm_classifier_nl.h	/^	uint8_t		proto;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
protocol	ecm_db.c	/^	int protocol;						\/* RO: Protocol of the connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
protocol	ecm_db.c	/^	int protocol;					\/* Protocol connection count iterator *\/$/;"	m	struct:ecm_db_state_file_instance	file:
protocol	ecm_tracker.h	/^	int protocol;			\/* The upper layer transport protocol *\/$/;"	m	struct:ecm_tracker_ip_header
protocol_number	ecm_tracker.h	/^	uint8_t protocol_number;		\/* IP protocol number *\/$/;"	m	struct:ecm_tracker_ip_protocol_header
qbc	ecm_classifier_default.h	/^	uint16_t qbc;$/;"	m	struct:ecm_classifier_default_sync
qos	ecm_classifier_default.h	/^	uint8_t qos;$/;"	m	struct:ecm_classifier_default_sync
qwr	ecm_classifier_default.h	/^	uint32_t qwr;$/;"	m	struct:ecm_classifier_default_sync
qws	ecm_classifier_default.h	/^	uint32_t qws;$/;"	m	struct:ecm_classifier_default_sync
reclassify	ecm_classifier.h	/^	ecm_classifier_reclassify_callback_t reclassify;$/;"	m	struct:ecm_classifier_instance
reclassify_allowed	ecm_classifier.h	/^	ecm_classifier_reclassify_allowed_get_callback_t reclassify_allowed;$/;"	m	struct:ecm_classifier_instance
recvd_bytes_total	ecm_tracker_tcp.c	/^	int32_t recvd_bytes_total;			\/* Current total of bytes of all buffers received *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
recvd_count	ecm_tracker_tcp.c	/^	int32_t recvd_count;				\/* Current total buffers received *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
recvd_order	ecm_tracker_tcp.c	/^	struct sk_buff *recvd_order;			\/* skbuffs inserted in order of reception *\/$/;"	m	struct:ecm_tracker_tcp_host_data	typeref:struct:ecm_tracker_tcp_host_data::sk_buff	file:
recvd_order_last	ecm_tracker_tcp.c	/^	struct sk_buff *recvd_order_last;		\/* skbuffs inserted in order of reception - tracks last insertion point for speed of appending *\/$/;"	m	struct:ecm_tracker_tcp_host_data	typeref:struct:ecm_tracker_tcp_host_data::sk_buff	file:
ref	ecm_classifier.h	/^	ecm_classifier_ref_method_t ref;$/;"	m	struct:ecm_classifier_instance
ref	ecm_front_end_types.h	/^	ecm_front_end_connection_ref_method_t ref;				\/* Ref the instance *\/$/;"	m	struct:ecm_front_end_connection_instance
ref	ecm_tracker.h	/^	ecm_tracker_ref_method_t ref;$/;"	m	struct:ecm_tracker_instance
refs	ecm_classifier_default.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
refs	ecm_classifier_dscp.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_classifier_dscp_instance	file:
refs	ecm_classifier_hyfi.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_classifier_hyfi_instance	file:
refs	ecm_classifier_nl.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_classifier_nl_instance	file:
refs	ecm_db.c	/^	int refs;							\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_listener_instance	file:
refs	ecm_db.c	/^	int refs;							\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_mapping_instance	file:
refs	ecm_db.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_connection_instance	file:
refs	ecm_db.c	/^	int refs;					\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_host_instance	file:
refs	ecm_db.c	/^	int refs;					\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_iface_instance	file:
refs	ecm_db.c	/^	int refs;					\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_db_node_instance	file:
refs	ecm_front_end_ipv4.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv4_connection_non_ported_instance	file:
refs	ecm_front_end_ipv4.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv4_connection_tcp_instance	file:
refs	ecm_front_end_ipv4.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv4_connection_udp_instance	file:
refs	ecm_front_end_ipv6.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv6_connection_non_ported_instance	file:
refs	ecm_front_end_ipv6.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv6_connection_tcp_instance	file:
refs	ecm_front_end_ipv6.c	/^	int refs;						\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_front_end_ipv6_connection_udp_instance	file:
refs	ecm_tracker_datagram.c	/^	int refs;				\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
refs	ecm_tracker_tcp.c	/^	int refs;									\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_tracker_tcp_internal_instance	file:
refs	ecm_tracker_tcp.c	/^	int refs;					\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
refs	ecm_tracker_udp.c	/^	int refs;				\/* Integer to trap we never go negative *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
relay_prefix	ecm_db_types.h	/^	uint32_t relay_prefix;				\/* Relay prefix *\/$/;"	m	struct:ecm_db_interface_info_sit
relay_prefixlen	ecm_db_types.h	/^	uint16_t relay_prefixlen;			\/* Relay prefix length*\/$/;"	m	struct:ecm_db_interface_info_sit
relevance	ecm_classifier.h	/^	ecm_classifier_relevence_t relevance;		\/* Is this classifier relevant to the connection? *\/$/;"	m	struct:ecm_classifier_process_response
remote_mac	ecm_db_types.h	/^	uint8_t remote_mac[ETH_ALEN];			\/* MAC Address of the PPPoE concentrator *\/$/;"	m	struct:ecm_db_interface_info_pppoe
return_dscp	ecm_classifier.h	/^	uint8_t return_dscp;				\/* DSCP mark for return *\/$/;"	m	struct:ecm_classifier_process_response
return_qos_tag	ecm_classifier.h	/^	uint32_t return_qos_tag;			\/* QoS tag to use for the packet *\/$/;"	m	struct:ecm_classifier_process_response
rt	ecm_interface.h	/^	} rt;$/;"	m	struct:ecm_interface_route	typeref:union:ecm_interface_route::__anon2
rtv4	ecm_interface.h	/^		struct rtable *rtv4;		\/* IPv4 route *\/$/;"	m	union:ecm_interface_route::__anon2	typeref:struct:ecm_interface_route::__anon2::rtable
rtv6	ecm_interface.h	/^		struct rt6_info *rtv6;		\/* IPv6 route *\/$/;"	m	union:ecm_interface_route::__anon2	typeref:struct:ecm_interface_route::__anon2::rt6_info
saddr	ecm_db_types.h	/^	ip_addr_t saddr;				\/* Tunnel source address *\/$/;"	m	struct:ecm_db_interface_info_sit
saddr	ecm_db_types.h	/^	ip_addr_t saddr;				\/* Tunnel source address *\/$/;"	m	struct:ecm_db_interface_info_tunipip6
segment	ecm_tracker_tcp.c	/^	struct sk_buff *segment;			\/* Current segment skb *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	typeref:struct:ecm_tracker_tcp_reader_instance::sk_buff	file:
segment_add	ecm_tracker_tcp.h	/^	ecm_tracker_tcp_segment_add_method_t segment_add;		\/* Add a prechecked MSS segment *\/$/;"	m	struct:ecm_tracker_tcp_instance
segment_dcb	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_skb_cb_format *segment_dcb;$/;"	m	struct:ecm_tracker_tcp_reader_instance	typeref:struct:ecm_tracker_tcp_reader_instance::ecm_tracker_tcp_skb_cb_format	file:
segment_offset	ecm_tracker_tcp.c	/^	uint32_t segment_offset;			\/* Offset from the start of the segment at which the next read will occur (header offset + data already advanced over in this segment) *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
segment_remain	ecm_tracker_tcp.c	/^	uint32_t segment_remain;			\/* Data bytes remaining to be read in this segment given the read pointer *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	file:
sender_data	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_host_data sender_data[ECM_TRACKER_SENDER_MAX];		\/* Data tracked sent by the src of the connection *\/$/;"	m	struct:ecm_tracker_tcp_internal_instance	typeref:struct:ecm_tracker_tcp_internal_instance::ecm_tracker_tcp_host_data	file:
sender_state	ecm_tracker_datagram.c	/^	ecm_tracker_sender_state_t sender_state[ECM_TRACKER_SENDER_MAX];$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
sender_state	ecm_tracker_udp.c	/^	ecm_tracker_sender_state_t sender_state[ECM_TRACKER_SENDER_MAX];$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
sender_states	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_sender_state sender_states[ECM_TRACKER_SENDER_MAX];	\/* Sender states *\/$/;"	m	struct:ecm_tracker_tcp_internal_instance	typeref:struct:ecm_tracker_tcp_internal_instance::ecm_tracker_tcp_sender_state	file:
seq_no	ecm_tracker_tcp.c	/^	uint32_t seq_no;				\/* Sequence number of the first data byte we are tracking *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
seq_no	ecm_tracker_tcp.c	/^	uint32_t seq_no;		\/* Sequence number of the first readable DATA BYTE in this buffer.  There may be others but they may be old. *\/$/;"	m	struct:ecm_tracker_tcp_skb_cb_format	file:
seq_no_valid	ecm_tracker_tcp.c	/^	bool seq_no_valid;				\/* True when our sequencing is valid *\/$/;"	m	struct:ecm_tracker_tcp_host_data	file:
serial	ecm_db.c	/^	uint32_t serial;					\/* RO: Serial number for the connection - unique for run lifetime *\/$/;"	m	struct:ecm_db_connection_instance	file:
serial_hash_index	ecm_db.c	/^	ecm_db_connection_hash_t serial_hash_index;		\/* The hash table slot whose chain of connections this is inserted into *\/$/;"	m	struct:ecm_db_connection_instance	file:
serial_hash_next	ecm_db.c	/^	struct ecm_db_connection_instance *serial_hash_next;	\/* Next connection in serial hash chain *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
serial_hash_prev	ecm_db.c	/^	struct ecm_db_connection_instance *serial_hash_prev;	\/* Previous connection in serial hash chain *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
sit	ecm_db.c	/^		struct ecm_db_interface_info_sit sit;			\/* type == ECM_DB_IFACE_TYPE_SIT (6-in-4) *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_sit	file:
size	ecm_tracker.h	/^	uint16_t size;				\/* Size of the header_size + its payload *\/$/;"	m	struct:ecm_tracker_ip_protocol_header
skb	ecm_tracker.h	/^	struct sk_buff *skb;		\/* COPY of POINTER to the skb this header relates to.  This ecm_ip_header is ONLY VALID for as long as the skb it relates to remains UNTOUCHED *\/$/;"	m	struct:ecm_tracker_ip_header	typeref:struct:ecm_tracker_ip_header::sk_buff
src_addr	ecm_tracker.h	/^	ip_addr_t src_addr;		\/* ECM ip address equivalent *\/$/;"	m	struct:ecm_tracker_ip_header
src_bytes_total	ecm_tracker_datagram.c	/^	int32_t src_bytes_total;		\/* Total bytes in all received datagrams *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
src_bytes_total	ecm_tracker_udp.c	/^	int32_t src_bytes_total;		\/* Total bytes in all received datagrams *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
src_count	ecm_tracker_datagram.c	/^	int32_t src_count;			\/* Count of datagrams in list *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	file:
src_count	ecm_tracker_udp.c	/^	int32_t src_count;			\/* Count of datagrams in list *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
src_ip	ecm_classifier_nl.h	/^	union ecm_cl_nl_genl_attr_ip src_ip;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple	typeref:union:ecm_cl_nl_genl_attr_tuple::ecm_cl_nl_genl_attr_ip
src_mac	ecm_classifier_nl.h	/^	uint8_t		src_mac[ETH_ALEN];$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
src_port	ecm_classifier_nl.h	/^	uint16_t	src_port;$/;"	m	struct:ecm_cl_nl_genl_attr_tuple
src_recvd_order	ecm_tracker_datagram.c	/^	struct sk_buff *src_recvd_order;	\/* sk buff list as sent by src *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	typeref:struct:ecm_tracker_datagram_internal_instance::sk_buff	file:
src_recvd_order	ecm_tracker_udp.c	/^	struct sk_buff *src_recvd_order;	\/* sk buff list as sent by src *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	typeref:struct:ecm_tracker_udp_internal_instance::sk_buff	file:
src_recvd_order_last	ecm_tracker_datagram.c	/^	struct sk_buff *src_recvd_order_last;	\/* Last skb send - for fast appending of new buffers *\/$/;"	m	struct:ecm_tracker_datagram_internal_instance	typeref:struct:ecm_tracker_datagram_internal_instance::sk_buff	file:
src_recvd_order_last	ecm_tracker_udp.c	/^	struct sk_buff *src_recvd_order_last;	\/* Last skb send - for fast appending of new buffers *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	typeref:struct:ecm_tracker_udp_internal_instance::sk_buff	file:
state	ecm_tracker_tcp.c	/^	ecm_tracker_sender_state_t state;		\/* State of the sender *\/$/;"	m	struct:ecm_tracker_tcp_sender_state	file:
state_get	ecm_tracker.h	/^	ecm_tracker_state_get_method_t state_get;$/;"	m	struct:ecm_tracker_instance
state_update	ecm_tracker.h	/^	ecm_tracker_state_update_method_t state_update;$/;"	m	struct:ecm_tracker_instance
stats	ecm_front_end_types.h	/^	struct ecm_front_end_connection_mode_stats stats;$/;"	m	struct:ecm_front_end_connection_instance	typeref:struct:ecm_front_end_connection_instance::ecm_front_end_connection_mode_stats
syn_seq	ecm_tracker_tcp.c	/^	uint32_t syn_seq;				\/* Sequence number of the syn (ISN): used to detect when peer has ack'd the syn, transitioned this sender to established. *\/$/;"	m	struct:ecm_tracker_tcp_sender_state	file:
sync_from_v4	ecm_classifier.h	/^	ecm_classifier_sync_from_v4_callback_t sync_from_v4;$/;"	m	struct:ecm_classifier_instance
sync_from_v6	ecm_classifier.h	/^	ecm_classifier_sync_from_v6_callback_t sync_from_v6;$/;"	m	struct:ecm_classifier_instance
sync_to_v4	ecm_classifier.h	/^	ecm_classifier_sync_to_v4_callback_t sync_to_v4;\/* Sync the classifier with state from the NSS *\/$/;"	m	struct:ecm_classifier_instance
sync_to_v6	ecm_classifier.h	/^	ecm_classifier_sync_to_v6_callback_t sync_to_v6;\/* Sync the classifier with state from the NSS *\/$/;"	m	struct:ecm_classifier_instance
tail	ecm_db.c	/^	struct ecm_db_timer_group_entry *tail;		\/* Least recently used entry in this timer group. *\/$/;"	m	struct:ecm_db_timer_group	typeref:struct:ecm_db_timer_group::ecm_db_timer_group_entry	file:
tcp_base	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_instance tcp_base;					\/* MUST BE FIRST FIELD *\/$/;"	m	struct:ecm_tracker_tcp_internal_instance	typeref:struct:ecm_tracker_tcp_internal_instance::ecm_tracker_tcp_instance	file:
tcp_from	ecm_db.c	/^	int tcp_from;$/;"	m	struct:ecm_db_mapping_instance	file:
tcp_nat_from	ecm_db.c	/^	int tcp_nat_from;$/;"	m	struct:ecm_db_mapping_instance	file:
tcp_nat_to	ecm_db.c	/^	int tcp_nat_to;$/;"	m	struct:ecm_db_mapping_instance	file:
tcp_to	ecm_db.c	/^	int tcp_to;$/;"	m	struct:ecm_db_mapping_instance	file:
tg	ecm_db.c	/^	ecm_db_timer_group_t tg;			\/* RO: The group id *\/$/;"	m	struct:ecm_db_timer_group	file:
ti	ecm_classifier_default.c	/^	struct ecm_tracker_instance *ti;			\/* RO: Tracker used while we detect MSS. Pointer will not change so safe to access outside of lock. *\/$/;"	m	struct:ecm_classifier_default_internal_instance	typeref:struct:ecm_classifier_default_internal_instance::ecm_tracker_instance	file:
time	ecm_db.c	/^	uint32_t time;					\/* Time in seconds a group entry will be given to live when 'touched' *\/$/;"	m	struct:ecm_db_timer_group	file:
time_added	ecm_db.c	/^	uint32_t time_added;						\/* RO: DB time stamp when the connection was added into the database *\/$/;"	m	struct:ecm_db_mapping_instance	file:
time_added	ecm_db.c	/^	uint32_t time_added;					\/* RO: DB time stamp when the connection was added into the database *\/$/;"	m	struct:ecm_db_connection_instance	file:
time_added	ecm_db.c	/^	uint32_t time_added;				\/* RO: DB time stamp when the Interface was added into the database *\/$/;"	m	struct:ecm_db_iface_instance	file:
time_added	ecm_db.c	/^	uint32_t time_added;				\/* RO: DB time stamp when the host was added into the database *\/$/;"	m	struct:ecm_db_host_instance	file:
time_added	ecm_db.c	/^	uint32_t time_added;				\/* RO: DB time stamp when the node was added into the database *\/$/;"	m	struct:ecm_db_node_instance	file:
timeout	ecm_db_types.h	/^	uint32_t timeout;					\/* Time this entry expires providing the timer group is not the ECM_DB_TIMER_GROUPS_MAX *\/$/;"	m	struct:ecm_db_timer_group_entry
timer_group	ecm_classifier.h	/^	ecm_db_timer_group_t timer_group;		\/* Timer group the connection should be in *\/$/;"	m	struct:ecm_classifier_process_response
timer_group	ecm_classifier_default.c	/^	ecm_db_timer_group_t timer_group;			\/* The timer group the connection should be in based on state *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
timer_group	ecm_tracker_udp.c	/^	ecm_db_timer_group_t timer_group;	\/* Recommended timer group for connection that is using this tracker *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	file:
timer_group_change	ecm_classifier_default.h	/^	ecm_classifier_default_timer_group_change_callback_t timer_group_change;$/;"	m	struct:ecm_classifier_default_instance
to	ecm_db.c	/^	int to;$/;"	m	struct:ecm_db_mapping_instance	file:
to_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_connections;		\/* list of connections made to this host mapping *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_connection_instance	file:
to_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_connections;		\/* list of connections made to this interface *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_connection_instance	file:
to_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_connections;		\/* list of connections made to this node *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_connection_instance	file:
to_connections_count	ecm_db.c	/^	int to_connections_count;					\/* Number of connections in the to_connections list *\/$/;"	m	struct:ecm_db_node_instance	file:
to_data_total	ecm_classifier_default.h	/^	uint32_t to_data_total;			\/* Amount of bytes sent by 'to' *\/$/;"	m	struct:ecm_classifier_default_sync
to_data_total	ecm_db.c	/^	uint64_t to_data_total;						\/* Total of data sent to this mapping *\/$/;"	m	struct:ecm_db_mapping_instance	file:
to_data_total	ecm_db.c	/^	uint64_t to_data_total;					\/* Totals of data as sent by the 'to' side of this connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_data_total	ecm_db.c	/^	uint64_t to_data_total;				\/* Total of data sent to this Interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
to_data_total	ecm_db.c	/^	uint64_t to_data_total;				\/* Total of data sent to this host *\/$/;"	m	struct:ecm_db_host_instance	file:
to_data_total	ecm_db.c	/^	uint64_t to_data_total;				\/* Total of data sent to this node *\/$/;"	m	struct:ecm_db_node_instance	file:
to_data_total_dropped	ecm_db.c	/^	uint64_t to_data_total_dropped;				\/* Total data sent by the 'to' side that we purposely dropped - the 'from' side has not seen this data *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_data_total_dropped	ecm_db.c	/^	uint64_t to_data_total_dropped;$/;"	m	struct:ecm_db_host_instance	file:
to_data_total_dropped	ecm_db.c	/^	uint64_t to_data_total_dropped;$/;"	m	struct:ecm_db_iface_instance	file:
to_data_total_dropped	ecm_db.c	/^	uint64_t to_data_total_dropped;$/;"	m	struct:ecm_db_mapping_instance	file:
to_data_total_dropped	ecm_db.c	/^	uint64_t to_data_total_dropped;$/;"	m	struct:ecm_db_node_instance	file:
to_interface_first	ecm_db.c	/^	int32_t to_interface_first;				\/* The index of the first interface in the list *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_interface_set	ecm_db.c	/^	bool to_interface_set;					\/* True when a list has been set - even if there is NO list, it's still deliberately set that way. *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_interfaces	ecm_db.c	/^	struct ecm_db_iface_instance *to_interfaces[ECM_DB_IFACE_HEIRARCHY_MAX];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_iface_instance	file:
to_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_nat_connections;		\/* list of NAT connections made to this host mapping *\/$/;"	m	struct:ecm_db_mapping_instance	typeref:struct:ecm_db_mapping_instance::ecm_db_connection_instance	file:
to_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_nat_connections;		\/* list of NAT connections made to this interface *\/$/;"	m	struct:ecm_db_iface_instance	typeref:struct:ecm_db_iface_instance::ecm_db_connection_instance	file:
to_nat_connections	ecm_db.c	/^	struct ecm_db_connection_instance *to_nat_connections;		\/* list of NAT connections made to this node *\/$/;"	m	struct:ecm_db_node_instance	typeref:struct:ecm_db_node_instance::ecm_db_connection_instance	file:
to_nat_connections_count	ecm_db.c	/^	int to_nat_connections_count;					\/* Number of connections in the to_nat_connections list *\/$/;"	m	struct:ecm_db_node_instance	file:
to_nat_interface_first	ecm_db.c	/^	int32_t to_nat_interface_first;				\/* The index of the first interface in the list *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_nat_interface_set	ecm_db.c	/^	bool to_nat_interface_set;				\/* True when a list has been set - even if there is NO list, it's still deliberately set that way. *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_nat_interfaces	ecm_db.c	/^	struct ecm_db_iface_instance *to_nat_interfaces[ECM_DB_IFACE_HEIRARCHY_MAX];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_iface_instance	file:
to_nat_next	ecm_db.c	/^	struct ecm_db_connection_instance *to_nat_next;		\/* Next connection made to the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
to_nat_node	ecm_db.c	/^	struct ecm_db_node_instance *to_nat_node;		\/* Node to which this connection was established *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_node_instance	file:
to_nat_prev	ecm_db.c	/^	struct ecm_db_connection_instance *to_nat_prev;		\/* Previous connection made to the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
to_next	ecm_db.c	/^	struct ecm_db_connection_instance *to_next;		\/* Next connection made to the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
to_node	ecm_db.c	/^	struct ecm_db_node_instance *to_node;			\/* Node to which this connection was established *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_node_instance	file:
to_packet_total	ecm_db.c	/^	uint64_t to_packet_total;					\/* Total of packets sent to this mapping *\/$/;"	m	struct:ecm_db_mapping_instance	file:
to_packet_total	ecm_db.c	/^	uint64_t to_packet_total;				\/* Totals of packets as sent by the 'to' side of this connection *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_packet_total	ecm_db.c	/^	uint64_t to_packet_total;			\/* Total of packets sent to this Interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
to_packet_total	ecm_db.c	/^	uint64_t to_packet_total;			\/* Total of packets sent to this host *\/$/;"	m	struct:ecm_db_host_instance	file:
to_packet_total	ecm_db.c	/^	uint64_t to_packet_total;			\/* Total of packets sent to this node *\/$/;"	m	struct:ecm_db_node_instance	file:
to_packet_total_dropped	ecm_db.c	/^	uint64_t to_packet_total_dropped;			\/* Total packets sent by the 'to' side that we purposely dropped - the 'from' side has not seen this data *\/$/;"	m	struct:ecm_db_connection_instance	file:
to_packet_total_dropped	ecm_db.c	/^	uint64_t to_packet_total_dropped;$/;"	m	struct:ecm_db_host_instance	file:
to_packet_total_dropped	ecm_db.c	/^	uint64_t to_packet_total_dropped;$/;"	m	struct:ecm_db_iface_instance	file:
to_packet_total_dropped	ecm_db.c	/^	uint64_t to_packet_total_dropped;$/;"	m	struct:ecm_db_mapping_instance	file:
to_packet_total_dropped	ecm_db.c	/^	uint64_t to_packet_total_dropped;$/;"	m	struct:ecm_db_node_instance	file:
to_prev	ecm_db.c	/^	struct ecm_db_connection_instance *to_prev;		\/* Previous connection made to the same mapping *\/$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_instance	file:
tos	ecm_db_types.h	/^	uint8_t  tos;					\/* Tunnel tos field *\/$/;"	m	struct:ecm_db_interface_info_sit
total_length	ecm_tracker.h	/^	uint32_t total_length;		\/* total length of IP header including all extensions and payload.  For v4 this is total_len, for v6 this is payload_len + size of the IP 6 header *\/$/;"	m	struct:ecm_tracker_ip_header
tracker_get_and_ref	ecm_classifier_default.h	/^	ecm_classifier_default_tracker_get_and_ref_callback_t tracker_get_and_ref;$/;"	m	struct:ecm_classifier_default_instance
tracking	ecm_classifier_default.c	/^	bool tracking;						\/* Are we tracking? *\/$/;"	m	struct:ecm_classifier_default_internal_instance	file:
ttii	ecm_tracker_tcp.c	/^	struct ecm_tracker_tcp_internal_instance *ttii;	\/* Reference to the internal tracker instance *\/$/;"	m	struct:ecm_tracker_tcp_reader_instance	typeref:struct:ecm_tracker_tcp_reader_instance::ecm_tracker_tcp_internal_instance	file:
ttl	ecm_db_types.h	/^	uint8_t  ttl;					\/* Tunnel ttl field *\/$/;"	m	struct:ecm_db_interface_info_sit
tunipip6	ecm_db.c	/^		struct ecm_db_interface_info_tunipip6 tunipip6;		\/* type == ECM_DB_IFACE_TYPE_TUNIPIP6 (IPIP v6 Tunnel i.e. TUNNEL6) *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_tunipip6	file:
type	ecm_db.c	/^	ecm_db_iface_type_t type;			\/* RO: Type of interface *\/$/;"	m	struct:ecm_db_iface_instance	file:
type_assignment	ecm_db.c	/^	struct ecm_db_connection_classifier_type_assignment type_assignment[ECM_CLASSIFIER_TYPES];$/;"	m	struct:ecm_db_connection_instance	typeref:struct:ecm_db_connection_instance::ecm_db_connection_classifier_type_assignment	file:
type_assignment_count	ecm_db.c	/^	int32_t type_assignment_count;			\/* Number of connections in the list *\/$/;"	m	struct:ecm_db_connection_classifier_type_assignment_list	file:
type_assignments_list	ecm_db.c	/^	struct ecm_db_connection_instance *type_assignments_list;$/;"	m	struct:ecm_db_connection_classifier_type_assignment_list	typeref:struct:ecm_db_connection_classifier_type_assignment_list::ecm_db_connection_instance	file:
type_get	ecm_classifier.h	/^	ecm_classifier_type_get_callback_t type_get;	\/* Get type of classifier *\/$/;"	m	struct:ecm_classifier_instance
type_info	ecm_db.c	/^	} type_info;$/;"	m	struct:ecm_db_iface_instance	typeref:union:ecm_db_iface_instance::__anon1	file:
udp_base	ecm_tracker_udp.c	/^	struct ecm_tracker_udp_instance udp_base;			\/* MUST BE FIRST FIELD *\/$/;"	m	struct:ecm_tracker_udp_internal_instance	typeref:struct:ecm_tracker_udp_internal_instance::ecm_tracker_udp_instance	file:
udp_from	ecm_db.c	/^	int udp_from;$/;"	m	struct:ecm_db_mapping_instance	file:
udp_nat_from	ecm_db.c	/^	int udp_nat_from;$/;"	m	struct:ecm_db_mapping_instance	file:
udp_nat_to	ecm_db.c	/^	int udp_nat_to;$/;"	m	struct:ecm_db_mapping_instance	file:
udp_to	ecm_db.c	/^	int udp_to;$/;"	m	struct:ecm_db_mapping_instance	file:
unknown	ecm_db.c	/^		struct ecm_db_interface_info_unknown unknown;		\/* type == ECM_DB_IFACE_TYPE_UNKNOWN *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_unknown	file:
v4_hdr	ecm_tracker.h	/^		struct iphdr v4_hdr;$/;"	m	union:ecm_tracker_ip_header::__anon3	typeref:struct:ecm_tracker_ip_header::__anon3::iphdr
v4_route	ecm_interface.h	/^	bool v4_route;				\/* True when a v4 route, false when v6 *\/$/;"	m	struct:ecm_interface_route
v6_hdr	ecm_tracker.h	/^		struct ipv6hdr v6_hdr;$/;"	m	union:ecm_tracker_ip_header::__anon3	typeref:struct:ecm_tracker_ip_header::__anon3::ipv6hdr
vlan	ecm_db.c	/^		struct ecm_db_interface_info_vlan vlan;			\/* type == ECM_DB_IFACE_TYPE_VLAN *\/$/;"	m	union:ecm_db_iface_instance::__anon1	typeref:struct:ecm_db_iface_instance::__anon1::ecm_db_interface_info_vlan	file:
vlan_tag	ecm_db_types.h	/^	uint16_t vlan_tag;				\/* VLAN tag of this interface *\/$/;"	m	struct:ecm_db_interface_info_vlan
vlan_tpid	ecm_db_types.h	/^	uint16_t vlan_tpid;				\/* VLAN tag protocol id *\/$/;"	m	struct:ecm_db_interface_info_vlan
xml_state_get	ecm_classifier.h	/^	ecm_classifier_xml_state_get_callback_t xml_state_get;$/;"	m	struct:ecm_classifier_instance
xml_state_get	ecm_db.c	/^	ecm_db_iface_xml_state_get_method_t xml_state_get;		\/* Type specific state method to return XML state for it *\/$/;"	m	struct:ecm_db_iface_instance	file:
xml_state_get	ecm_front_end_types.h	/^	ecm_front_end_connection_xml_state_get_callback_t xml_state_get;	\/* Obtain XML formatted state for this object *\/$/;"	m	struct:ecm_front_end_connection_instance
xml_state_get	ecm_tracker.h	/^	ecm_tracker_xml_state_get_callback_t xml_state_get;		\/* Return an XML element containing its state *\/$/;"	m	struct:ecm_tracker_instance
